### Rust学习笔记



#### Rust语言介绍

Rust语言是一个强类型的静态语言，强类型的意思是对变量类型的约束会比弱类型的语言（比如JS）要多很多，静态的意思是程序必须在编译期就确定所有变量的类型，这些特点使得**Rust不需要GC(Garbage Collection)**，只要能通过编译期，运行时就OK，不会有内存泄露的问题。



#### 入门

安装运行环境`rustup`，它是类似NVM的工具，负责安装和管理不同版本的rust编译器。首先需要C++环境，因此要安装微软的C++生成工具（不确定是否需要安装完整的Visual Studio），直接选择使用C++的桌面开发，语言包一定要选上英语：

![image-20240304223251058](assets/image-20240304223251058.png)

安装完成后记得把路径加到系统变量内，路径是：

```
[root]\VC\Tools\MSVC\[version]\bin\Hostx64\x64
```

然后有2个安装rust的方案，一个是直接去下载[rustup-init](https://www.rust-lang.org/learn/get-started)，选64位版本，安装之前在系统变量里面加上`CARGO_HOME`，指向一个自定义路径，然后执行安装文件，选择默认安装方式。这个CARGO_HOME和GRADLE_HOME，NPM_HOME一样都是包管理工具，即**CARGO是RUST的包管理工具，还能构建RUST项目**。

安装完成后检查一下系统变量PATH里面是否有一个`%CARGO_HOME%\bin`，如果没有就手动加一下，它允许我们使用`cargo`命令，用来创建项目。

还有一个方案是使用MSYS2安装rust，这种方法更接近linux原生的操作，具体不介绍了。

安装好之后执行以下命令测试一下，注意大小写：

```
rustup -V
rustc -V
```

RUSTUP是管理RUST版本的工具，rustc就类似javac一样，是一个具有编译期的语言，实际上rust强大的地方就在于它的语言设计，使得只要通过了编译期，基本运行时就不会出错，也就不再需要GC进行内存管理，即**把内存管理提前到了编写阶段**。

然后是IDE了，这里用VS Code，安装好之后，去插件市场安装`rust-analyzer`，这个插件还在更新，比官方的插件更好用。

然后所需的工具基本都有了。验证cargo是否装好的命令如下：

```
cargo --version
```

之后创建项目，在工作空间里面执行此命令：

```
cargo new rust_demo
```

`cargo new`是创建项目的命令，可以带一些参数，默认情况下会创建了一个带有GIT配置的RUST项目，然后用VS CODE打开它，可以发现项目结构如下：

```
root
  |---src
  |---target
  |---.git
  |---.gitignore
  |---Cargo.toml
  |---Cargo.lock
```

简单理解一下：

- src就是源码路径
- target就是编译后的文件
- git和gitignore不多说
- Cargo.toml类似package.json，用于声明项目信息以及包依赖，它有一个VS CODE插件叫Even Better TOML，用于优化TOML文件展示效果，以及语法检查等，TOML语法还是比较简单，就是定义一组根配置（对象），每个根配置内通过key=value来控制具体的属性值，还是面向对象的思路
- Cargo.lock，类似package-lock.json，应该是用于辅助Cargo.toml进行精确依赖控制的，由Cargo自动生成，开发者不用维护它，**但是如果提交代码，这部分也要提交进去，以确保所有参与者下载的依赖版本都是相同的**

然后在VS CODE里面调出终端界面，可以通过命令行执行代码了，src里面默认创建了一个`main.rs`文件，看来rust源码的文件后缀名就是rs，它的内容是这样：

```rust
fn main() {
    println!("Hello, world!");
}
```

官方推荐的缩进是**4个空格**，这里按官方的来，具体可以查阅[官方风格指南](https://doc.rust-lang.org/nightly/style-guide/)，最重要的**命名风格，大部分时候是snake_case（文件名，变量名，方法名等）**，常量采用SCREAMING_SNAKE_CASE，其他场景遇到了再说。

然后命令行执行，注意不要cd到src里面，直接在项目根路径执行即可：

```
cargo run
```

就会开始一个正常的编译 + 执行流程，效果如下：

![image-20240305001509914](assets/image-20240305001509914.png)

编译完成后可以在项目的target路径内看到编译好的文件，适配不同平台，比如windows是exe文件。RUST和JAVA一样编译和运行是分开的，此外编译后的文件，可以放在相同平台的其他设备上运行，即使对方设备没有安装RUST编译环境也可以。

`cargo run`是一个复合命令，表示检测是否有变动，如果有，重新编译，最后执行编译结果，也可以用`cargo build`来只做编译，用于验证语法和编译是否OK，如果连续执行run，因为代码没有变动，所以会跳过编译阶段直接执行上次的编译结果。



#### CARGO常用命令（后续慢慢补充）

- cargo --version，查看版本号
- cargo new [project_name]，创建RUST项目

- cargo run，检测是否有变动，如果有，重新编译，不管是否有变动，最终都会执行编译结果
- cargo build，执行编译，如果在TOML里面声明了依赖包，会先尝试下载缺失的依赖包，默认是debug模式，会在target/debug路径下产生结果，如果需要进行生产模式编译，加上`--release`参数即可，当然生产模式编译会带来更长的编译耗时，和更好的运行性能
- cargo check，检测语法是否OK，是否能顺利编译，如果build开销较大可以先用check确认语法OK后再build，check就是语法检查，在RUST里面开销很小，推荐经常使用
- cargo doc --open，本地构建当前项目所有依赖的文档，并在浏览器中打开，需要快速查看依赖包的API的时候非常管用，不过还是建议去各个依赖项目的主页找文档，会更清晰

针对一般开源项目，如果要在本地跑起来，也是用CARGO去编译：

```
git clone [example.org/someproject]
cd [someproject]
cargo build
```



#### 分割文件

学习过程中会需要写很多例子，如果全部写在main.rs内就不好维护，所以先简单学习如何分割文件。

先简单理解，一个单独的文件就是一个模块，它的使用是这样的：

- 创建一个单独的文件，RUST会把它视为单独的模块，模块名称就是文件名
- 在新文件内声明函数，并声明此函数可以导出
- 在入口文件（main.rs）把新文件声明为模块，这样就可以使用模块内导出的函数了

具体例子，先在main.rs同层级构造一个文件`hello_world.rs`，内容如下：

```rust
pub fn run() {
    println!("Hello Rust!");
}
```

这里的`pub`关键字就表示此函数已经导出了，可以供外部使用。

然后在入口文件内这样写：

```rust
mod hello_world;

fn main() {
    hello_world::run();
}
```

使用`mod`关键字来告诉编译器，把这个新文件视为一个模块，**即只能在入口文件内去让编译器把其他文件视为模块**。

最后就是使用关键字`::`来调用文件内暴露的方法了。

和JS不同，**RUST的模块内不能通过全局的单独声明变量来触发闭包，因为闭包本质上是内存泄漏的一种，而RUST是严防内存泄漏的**，因此下面这段代码是**$\textcolor{#DC143C}{错误} $**的：

```rust
let counter = 0; // 这里是错误的
pub fn run() {
    counter += 1;
    println!("counter is = {counter}");
}
```

但是RUST有别的方法可以实现，只不过写起来会有一些难度，后面会提到。



#### CARGO基本配置

CARGO镜像源配置，和NPM一样可以指定下载镜像源，通过指定为国内镜像源，可以避免开VPN，具体在CARGO_HOME对应的路径下面创建一个config.toml文件，注意TOML语法都是从一组根对象开始的，然后这样写：

```toml
[source.crates-io]
replace-with = "ustc"

[source.ustc]
registry = "https://mirrors.ustc.edu.cn/crates.io-index"
```

USTC表示中国科技大学，用它们的镜像。

**CARGO不像NPM那样可以直接配置多个源然后逐个遍历**，一般来说只能配置一个，有一种配置方法可以配置多个，但是实际使用时必须指定一个源，和只配置一个源没有太大区别，注意不要频繁更换源，每次更换源之后都会重新创建仓库索引，会比较慢。

依赖声明，在项目的Cargo.toml里面这样写：

```toml
[dependencies]
time = "0.3.34"
regex = "1.10.3"
```

注意版本号使用x.y.z表示法。

另外CARGO好像没有命令行查看某个包的所有版本的功能，如果需要可以去[这里](https://crates.io/)查。

依赖下载也使用`cargo build`命令，会在编译期间自动寻找缺失的依赖然后下载。依赖包会放在`CARGO_HOME\registry\src\[SOURCE]\`，看上去像MAVEN那样是一个本地的中央仓，而不是NPM那样各个项目有自己的依赖。



#### 猜数字游戏

这里跟随教程做一个猜数字游戏，和教程不同，不需要创建一个项目，直接在现有项目内通过分割文件的方式来搞。

需求：

- 每次游戏开始，先生成固定范围内的随机数作为答案，然后让用户不停输入去猜这个数字，猜对了游戏结束，猜错了给出对应提示，并让用户继续输入，直到猜对为止

- 支持用户输入，用户只能输入数字，如果输入其他字符或者数字超出范围则必须让用户重新输入
- 用户输入数字后，和答案比较大小，并给出过大或者过小或者猜对的提示
- 猜错时提示用户继续输入，猜对时结束游戏

样例代码：

```rust
// 使用std内相关库
use std::{cmp::Ordering, io};
// 使用随机数的库
use rand::Rng;

pub fn run() {
    println!("Guess the number!");

    // 设置随机数的范围
    let range_min = 1;
    let range_max = 100;

    // 根据范围构造一个随机数，闭合区间
    let random = rand::thread_rng().gen_range(range_min..=range_max);

    // 构造一个循环，里面让用户不停输入，直到猜中数字为止
    loop {
        let result = single_run(random, range_min, range_max);
        if result == 0 {
            break;
        }
    }
}

fn single_run(answer: i32, range_min: i32, range_max: i32) -> i32 {
    println!("Please input a number from {} to {}!", range_min, range_max);

    let user_guess: i32 = get_user_number(range_min, range_max);

    // 比较用户输入和答案
    number_compare(user_guess, answer)
}

/** 开启一个输入流，获取用户输入并转为数字 */
fn get_user_number(range_min: i32, range_max: i32) -> i32 {
    let mut user_guess: i32;
    
    // 开启一个小循环用于处理用户输入，如果是非数字就让用户继续输入，直到拿到数字为止
    loop {
        // 构造一个String类型的变量，且它的地址可变，每次获取用户输入时都要重新构造此变量
        let mut user_in = String::new();
        // 获取用户在换行之前的输入信息，并把这些信息拼接到user_in变量原有的信息后面，形成一个新的字符串
        // 让user_in变量指向到拼接后的字符串地址
        io::stdin().read_line(&mut user_in)
        // 异常处理，注意这里是链式调用写法，为了阅读便利性建议每次链式调用时，就新开一行并加上缩进
            .expect("Failed to read input");
        
        // 用户输入字符串转数字，注意parse方法是泛型方法，这里要传入具体类型
        user_guess = match user_in.trim().parse::<i32>() {
            Ok(num) => num,
            Err(_) => {
                // 用户输入不能转为数字的时候，给出提示，并让用户重新输入
                println!("Please only input numbers!");
                continue;
            },
        };

        // 如果数字超范围则不采用
        if user_guess > range_max || user_guess < range_min {
            println!("Please input a number between {} and {}!", range_min, range_max);
            continue;
        } else {
            break;
        }
    }
    
    // 不带分号结尾表示返回一个表达式
    user_guess
}

/** 比较2个数字 */
fn number_compare(a:i32, b:i32) -> i32 {
    let result = match a.cmp(&b) {
        Ordering::Less => {
            println!("too small");
            -1
        }
        Ordering::Equal => {
            println!("You guessed right, you win!");
            0
        }
        Ordering::Greater => {
            println!("too big");
            -1
        }
    };
    result
}
```

步骤分解：

- 随机数通过引入rand库来实现
- 用户输入通过std::io来实现
- 用户输入的处理通过循环loop来控制，输入的都是字符串，是否能转数字通过parse方法确定，转为数字后再判断大小，超出输入范围也提示重新输入（其实没有必要，只要是数字就可以比较大小，加上当然更易用）
- 用户输入完成后和随机数比较大小并返回比较结果和提示
- 把用户输入 => 比较大小看作一个循环，每次循环拿到猜测结果，猜错时继续这个循环，猜对了结束循环，同时结束游戏

最后基于这个设计先完整写一遍，然后优化一下结构，把各个环节抽取为函数。



#### 基础概念和语法

**关键字不能用于任何的变量或者函数**，比如for | loop | match | if等等，这个算是所有编程语言的常识了，原因是解析器遇到关键字就是会无条件当作关键字来构造语法树。



##### 声明和表达式和代码块

RUST里面，一般在代码块或者函数的末尾，用一个**不带分号的运算来作为表达式**，而带分号的，不管其内容，都会被视为一段指令：

```rust
// 这是一个表达式，变量声明，也可以把等号右侧的3看作一个表达式，但是整体上它是一个声明
let a = 3;
```

**表达式本质是一个值**，值要么给变量绑定要么用于运算结果，指令就是运算或者绑定本身，所以`let a = (let b = 3);`会报错，因为指令不是值，是运算过程，指令不能绑定给变量，只有表达式可以，比如`let a = 1 + 1;`，这里的`1 + 1`就是表达式。

表达式则一般用于函数的返回值，或者一些流程控制的片段末尾，可以省略`return`关键字，不省略时就要用`return [expr];`（注意这里带了分号，所以是一个指令）来表示函数或者代码块的返回值：

```rust
// 以下两种返回写法等价
fn test() -> i32 {
    return 3;
}

fn test2() -> i32 {
    3
}
```

RUST内可以通过`{}`符号随意地构建代码块，一个代码块就是一个作用域，比如：

```rust
{
    println!("code block");
}
let b = {3}; // 这种算是最简单的代码块了，它直接返回一个表达式
println!("{}", b);
```

代码块可以理解为JS里面的IIFE（立即执行的函数表达式），它里面既可以包括指令，也可以用表达式返回结果，只有返回了结果的代码块，可以绑定到变量。此外像函数，或者是后续提到的流程控制等，都会结合`{}`符号，这些也是代码块。



##### 变量声明

**单独的`let`修饰的变量是不可变的**，类似JS里面的`const`：

```rust
let a = 3;
```

如果后续修改let变量的值，在编译期就会报错，比如：

```rust
let a = 3;
a = 4; // 到这里就会报错

if a > 2 {
    a = 5; // 可能的修改也不可以
}
```

换言之**单独用let关键字修饰的变量，是在任何条件下都不可变的**，这里先不考虑对象变量的问题，RUST里面的所谓的对象也要遵守相同的规则。**可变性和不可变性，结合借用机制，是RUST能保证运行时无GC且不出BUG的前提**。

如果需要它可变，就要使用`let mut`修饰：

```rust
let mut a = 3;
a = a + 2;
println!("result is {}", a);
```

**注意这里的可变性是指变量的值可以改，但是类型不能改**，如果尝试修改类型，也会报错，比如：

```rust
let mut a = 3;
a = "some text2"; // 这行会报错，因为改数据类型了
```

**正因为`mut`无法解决修改变量类型的问题，所以RUST通过变量遮盖（shadowing）来解决需要同一个变量但是也需要它能改类型的问题**，比如：

```rust
let a = 3;
println!("a is {}", a);
let a = "some text"; // 不会报错
// 下面直接开启一个作用域
{
    let a = "another text";
    println!("a is {}", a); // 这里当然会输出another text
}
println!("a is {}", a); // 输出some text，因为上面的作用域结束了
```

变量遮盖可以视为在同一个名称的变量上叠加不同的值，每个值都有其作用域，当到达作用域边界外时，这个值就失效了，因此它从这个变量上撤下，即不再遮盖，这样此变量就指向了它被遮盖之前的值。

**变量遮盖的最佳实践就是希望表示同一个概念，但是需要转换类型的时候，其他场景下会产生歧义**，如果类型不会变，直接用`mut`吧。

`const`在RUST里面也是关键字，用于修饰完全不可变的变量，就是字面意义上的常量，完全不可变（不能用`mut`修饰），而且声明时需要声明类型，比如：`const a: i32 = 3;`，不过从编程风格上，因为它完全不可变，一般都会用SCREAMING_SNAKE_CASE风格来命名，所以最佳实践写法是：

```rust
const DAYS_OF_WEEK: i8 = 7;
const LOOP_INTERVAL_IN_SECONDS: i32 = 60 * 60 * 24;
```



##### 数据类型

RUST里面数据类型分2类，scalar和compound，前者可以理解为基本类型，后者可以理解为复合类型（不要理解为对象类型，RUST包括了一部分面向对象特性但它本质不是基于面向对象设计的），但不管是哪种，编译器都必须对所有变量的类型有完全的掌握，掌握了类型就确定了变量的大小范围，一些不定长的比如数组，字符串等，和其他的语言一样都会存于堆内，而**定长的基本类型都放在栈内，其大小在编译期就确定了，一旦开始运行，给它分配的空间就是确定的，后续不会再有变化**。



##### 数据类型--基本类型

此外基本类型也不是一般面向对象编程里面的那种基本类型，它里面还是有封装一些方法的。

基本类型包括整数，浮点，布尔，char，就4种。

整数类型表示如下：

```rust
let b: u8 = 0;
let c: u8 = 255;
println!("{}, {}", b, c);
```

类型说明如下：

| 类型关键字    | 类型说明                                                     |
| ------------- | ------------------------------------------------------------ |
| i8 / u8       | 8位长度                                                      |
| i16 / u16     | 16位长度                                                     |
| i32 / u32     | 32位长度                                                     |
| i64 / u64     | 64位长度                                                     |
| i128 / u128   | 128位长度                                                    |
| isize / usize | 长度根据平台确定，比如早期X86架构下就是32位长度，一般现代电脑都是64位长度 |

i开头的表示支持负数，所以边界值是$-(2^{n-1})$到$2^n - 1$，所以i8范围是-128到127。

u开头的表示不支持负数，所以边界是从0到$2^n$，所以u8范围是0到255。

另外整数型的写法可以有多种，常见的有：

```rust
let int1: i32 = 34567; // 标准写法
let int2: i32 = 34_567; // 更优雅的十进制写法
let int3: i32 = 0xFFF; // 16进制写法
let int4: i32 = 0b10010010; // 2进制写法
let int5 = 1; // 默认是i32类型
println!("{}, {}, {}, {}", int1, int2, int3, int4);
```

不声明类型时，解析器默认使用i32。

基本类型存于栈内，大小在一开始就确定了，而数学运算可能会导致类型溢出，RUST需要对此做处理，在开发模式下，遇到此类问题会直接报错，而生产模式下默认会采用溢出后从头开始循环的策略，比如u8的256会等于0，u8的257会等于1，如果需要在业务逻辑上感知溢出并处理，简单的方法是：

```rust
let overflow: u8 = 254;
match overflow.checked_add(4) {
    Some(v) => println!("success, {}", v), // 没有溢出，正常往下走
    None => println!("overflowed") // 溢出了，做异常处理
};
```

后续可以通过一些封装类型，在变量声明的时候就给定了溢出的处理策略，以减少每次运算都要调用溢出处理方法的问题。

浮点类型只能针对十进制，都支持负数，类型是`f32`和`f64`，默认是`f64`因为要支持现代的平台。写法就是正常的比如`1.0`，`3.1415926`等等。注意**由于不声明变量类型时，默认是i32整数型，会导致除法类数学运算产生偏差，忽略小数的部分，所以需要更精确的数学运算时，建议都显式声明为浮点类型**。

布尔类型没什么好说的，和其他语言基本一样，关键字是`bool`，值是`true`和`false`。**RUST里面不支持JS的那种布尔隐式转换，所以`let a: bool = 1;`这种写法会报错**。

char类型，就是单字符类型，写法如下：

```rust
let single_char: char = 'X';
```

类型是`char`，**用单引号表示一个字符**，所以RUST内**双引号表示的都是和字符串相关的，不会和char相关，哪怕是双引号包裹一个单字符，也被视为字符串相关**。char的长度是4byte，也就是32位，UTF-8下中文一般是3byte，所以char类型几乎可以表示所有的语言的单个字符。



##### 数据类型--基本的复合类型

注意这个标题，基本的复合类型，即有很多种复合类型，这里只介绍最基本的复合类型。

tuple，中文翻译叫元组，更准确的翻译是**有限复合集**，比如couple => triple => n-tuple。在RUST内tuple表示一组有序列的，多类型的（可以是基本类型和复合类型，不限定）的变量集合，它的特点是：

- 元素数量固定，一旦声明了其元素数量不可变
- 有序的元素类型，即每个元素都可以自由选择其类型，但是各个位置上的元素，其类型不可变

所以对tuple最好的理解是，**它是一个有限复合集，每个元素都有其序号和数据类型，且集合不可扩容或者缩减，元素类型也不可变更**。

写法如下：

```rust
let cube_size: (i32, i32, i32) = (100, 20, 40);
println!("cube length = {}, width = {}, height = {}", cube_size.0, cube_size.1, cube_size.2);

let item = ("potion", 5); // 让RUST自己去推导tuple的类型
let (item_name, item_quantity) = item;
println!("item: {}, quantity: {}", item_name, item_quantity);

let location: (f64, f64) = (108.35678, 46.34567);
let (lat, lng) = location;
println!("lat = {}, lng = {}", lat, location.1); // 基本类型的tuple在被解构后依然可以访问到
```

每个tuple变量都表示一个允许多类型元素的集合，因为是有序的，所以可以用`.[下标]`的方式访问，从0开始，也可以通过`let ([var1], [var2]) = [tuple]`这种方式去解构tuple（这里就涉及到所有权了，暂时先理解为解构）。

tuple本质上要作为一个数组来看待，而且支持多类型使得它更具有业务意义，当业务需要返回一些复杂信息，但是又不希望用更复杂的面向对象的处理方法时，就可以采用tuple，比如API接口类型的可以是`(i32, data)`表示响应码和响应体，地点坐标的可以是经纬度，物体尺寸的可以是长宽高。**tuple元素不宜过多，这样业务上好理解**。

array，即数组类型，RUST中的数组特点如下：

- 和tuple一样也是固定长度
- 所有元素必须是同一种类型

举例：

```rust
let arr1 = [1,2,3,4];
let arr2: [u8; 3] = [1, 1, 1]; // 显式声明了数组类型
let arr3 = [10; 2]; // 等于[10, 10]
let arr4: [u8; 2] = [10; 2]; // 声明类型的同时也创建了元素
println!("arr1 first = {}", arr1[0]); // 通过下标访问
println!("arr1 last = {}", arr1[5]); // 会在编译期报错
```

由于数组是固定长度的，因此在编译期就可以确定通过下标访问是否会越界。



##### 函数声明

一个RUST项目要能通过`cargo run`跑起来，需要有一个入口模块和对应的入口函数，约定俗称的就是main.rs和main函数。

函数声明的语法是：

```
[函数修饰符，非必要] fn [函数名称](参数1: 类型, 参数2: 类型......) -> 返回值的类型(如果没有就用括号代替或者省略箭头) {
    // 函数体和返回值
}
```

函数名称和变量名称一样采用snake_case风格，**返回值类型不能像变量那样自动推导**，即如果函数体内有返回值，则必须显式声明返回值类型，没有返回值类型时，可以省略箭头，或者写为括号，比如`fn no_return_value() -> () {}`，所以省略箭头就是语法糖，相当于显式声明返回`()`类型。

**函数体的`{}`不能省略**，所以一个带了返回值的最简单的函数要这样写：`fn test() -> i32 { 99 }`。

**函数声明不分先后顺序**，因为RUST有完整的编译阶段，所以只要在编译期结束之前，RUST能定位到代码内调用的函数所指向的实现，就没有问题。

注意函数体既然用到了`{}`，那么本质就是代码块了，而**代码块内是可以声明函数的**，所以**函数内也可以继续声明函数**：

```rust
fn main() {
    let a = get_a();
    println!("result is {}", a);

    fn get_a() -> i32 { 99 }
}
```



##### 注释写法

```rust
// 单行注释，写在本位置后面的内容全部都视为注释
/* 行内注释，写在本位置内的内容都是注释，可以在本注释前后加代码 */
let /* 行内注释可以写到代码空格的位置，虽然不建议这样写但是也不会报错 */ b: i32 = test();

/*
 * 行内注释通过换行可以转为多行注释，为了美观每行开头可以加一个星号，当然不加也可以
*/

// 下面描述如何写一个API的注释
/// 对函数整体的描述，返回值的含义写在这里
/// * `arg1` 对入参的描述
fn test(arg1: i32) -> i32 { 
    99 
}
```

RUST目前还不支持`@foo`这样的注释，如果要写文档基本就是用`///`符号，加上格式化的文字来描述一个函数或者变量它的作用。



##### 流程控制

最常用的写法是使用`if / else if / else`来处理流程控制，比如：

```rust
let number = 3;

if number < 5 || number > 8 {
    println!("condition1");
} else if number >= 5 && number < 8 {
    println!("condition2");
} else {
    println!("some strange condition");
}
```

条件本身不要带括号，此外注意if本身也是接代码块的，因此也可以用表达式来返回，且进行赋值，比如：

```rust
let a = if condition { 5 } else { 6 };
```

这里要注意**if条件中所有代码块都要返回相同类型的值，还是那个老问题，在编译期，所有变量的类型都要确定下来**，因为类型跟分配的内存大小直接相关。

还可以用`loop`结合`continue / break`来控制流程，这个在之前的猜数字游戏里面已经演示过了，这里再写一个例子：

```rust
let mut counter = 0;
loop {
    if counter > 5 {
        break;
    } else if counter == 4{
        counter += 1; // 这里修改了counter的增加量，并且跳过了循环中的其余流程，导致最后退出循环时结果不同
        continue;
    }
    counter += 2;
}
println!("end, counter = {}", counter);
```

还可以用`while`代替`loop`，多了一个每次循环时的条件检测，不复合条件时会自动退出循环，举例：

```rust
let mut number = 3;
while number > 0 {
    if number == 1 {
        number -= 2; // 这里修改了循环到1的时候的流程
        continue;
    }
    number -= 1;
}
println!("last number = {number}");
```

因为能自动退出循环所以可以不写break，但是结合条件语句还是能用continue控制循环节点。

for循环，常用的是for in写法，可以遍历数组但是不能遍历tuple（因为tuple是有限复合集，元素类型是可变的，不能赋值给单一的迭代器变量），举例：

```rust
let arr = [1,2,3,4,5];
for ele in arr {
    println!("for loop, ele = {ele}");
}
```

如果要在遍历时拿到元素的下标，则需要显式地使用迭代器处理，这个后面会提到。



#### 所有权

所有权是RUST的核心设计，就是基于这个设计可以实现运行时无GC，所以它最重要的特点是可以保证内存安全。



##### 什么是所有权

所有权是RUST管理内存的一套规则，也是用于规范代码的规则。

早期的编程语言采用完全开放给开发者的策略，即开发者要手动指定内存空间存放数据，并在使用完成后手动释放空间，**这导致了极大的编程难度**，因为一次分配必须对应一次释放，中间有太多容易出错的地方，比如分配过小，没有释放，过早释放，释放多次，都会导致程序运行出BUG，因此后期的编程语言大都采用自动化的管理机制，即GC，通过开启一个GC线程来持续扫描内存中的变量，找出不再被使用的部分然后销毁。但有好处也有坏处，GC线程的存在会导致运行时的额外开销，而且不同的GC有不同的策略，巧妙的编写有时候可以让变量逃脱GC的控制，因此也无法杜绝内存泄漏的问题。

为此，RUST采用的是代码规范+编译期校验的方法，即如果代码不规范，或者编译期校验没有通过，则根本不会开始编译和运行，反之，如果都通过了，则能保证运行时不会有内存泄漏的问题。

要理解RUST的所有权就要先理解RUST的内存管理机制。和大部分编程语言类似，RUST也是通过栈和堆来管理内存的。栈就是先进后出，栈顶元素是最后加入的，但是最先出去的，此外**所有栈内变量都必须要在编译期就知道它的最大长度**，因为栈的内存也是有限的所以不可能存储像字符串这样的不限制大小的变量。所以所有在编译期不能确定最大长度的变量，统统都要存到堆里面。

堆的内存管理比较松散，**如果把栈理解为叠盘子，那么堆就是码头仓库**，需要的时候申请一块空间，用于堆放货物（变量），用完之后把货物挪走（变量销毁），清出空间，供下一批货物使用，有些货物体积大，占用空间就多，有些体积小，占用空间就少。有时候一个大体积的货物被清走了，它留下的空间可以够放好几个小体积的货物。当存放了货物后，这个货物的所有者就可以拿到这个货物在仓库中的位置坐标，这个坐标会被所有者存于栈内，由于仓库的大小是固定的（RUST运行时不可能给堆分配超出平台限制的内存地址），因此它内部所有货物的可能的坐标也是能确定大小的，因此它就一定可以存于栈内，即货物坐标在栈内，货物本身在堆内。

栈的管理是严格大小的，后进先出的，堆的管理是松散的，空间的分配是临时确定的，因此操作栈比操作堆更有效率。

RUST基于栈堆内存管理机制，设计了以下所有权的基本规则：

- 每个值都要关联一个所有者（owner）
- 每个值，在任何时间切面上看，都只能关联一个所有者
- 所有者消失时，它关联的值也必须消失

现在以这个代码为例解释以下所有权：

```rust
let s = "hello";
```

上述代码，变量s就是所有者，它关联的值是字符串切片hello（不是字符串类型，两者区别后面会提到），由于变量s处于一个代码块中（最少它也要放在一个函数内执行），因此当执行到代码块的外侧时，此变量s就要消失，它关联的值，字符串切片hello也必须消失。



##### 用字符串类型来解释所有权

**基本类型的变量无法解释所有权的概念**，因为基本类型都是存在于栈内，大小已知，**RUST给这些基本类型都加上了copy特性**，把它们的赋值操作都变为了**复制**操作，导致它们用起来和其他的编程语言没有什么区别，比如下面这段代码是正常的：

```rust
let a = 3;
let b = a;
let c = a + b;
```

关于特性的部分后面会提到，这里简单了解就是，基本类型之所以可以随便用，就是因为RUST给它们加上了copy特性。所以，要解释所有权只能用RUST没有加copy特性的类型，也就是复合类型，存于堆内的，而字符串，`String`类型，就是一个很好的例子，比如我们需要一个字符串变量，它的值只能在运行时确定时，应该这样写：

```rust
let mut s = String::from("");
println!("text is {s}, end");
s.push_str("hello string");
println!("text is {s}, end");
```

通过`String::from`来构建一个字符串类型，这里`foo::bar`表示调用的是foo这个类型上的静态方法。然后是字符串拼接，因为要拼接，等于修改了值，所以变量必须是可变的，通过`push_str`来拼接值。但是注意，字符串字面量，也就是**代码内直接写死的字串，是没有这个方法的**，比如下面这段代码会**$\color{#DC143C}{报错}$**：

```rust
let mut s2 = "aa";
s2.push_str("bb"); // 到这里就报错了
println!("{s2}");
```

这里就牵扯到了写死字串和字符串的类型区别。写死字串，其大小长度，编译期是已知的，因为它写死了，但是它也不是存于堆内，**而是会直接保存在编译后的二进制文件的只读数据区域内**，所以如果在代码内写死，保存了一部小说，这部分小说也只是会增大编译后的二进制文件的总体体积，不会对运行时的堆有什么影响。

字符串类型的变量，初始化时会在堆上分配一块空间，这个代码`let mut s = String::from("");`表示在堆上分配了空间后，把地址返回给变量s，s就是这个值的所有者，所以按照所有权的基本规则，**当代码执行到s所在代码块外侧时，s会消失，它关联的堆上的值也会被释放**，即：

```rust
{
    let mut s = String::from("");
    
    // 做一些字符串的操作
}
// 到这里，s就消失了，它的值占用的堆空间也被释放了 
```

 基于字符串有真正的所有权的概念，下面这段按照基本类型的赋值，引用的操作，在字符串这里会报错：

```rust
let mut s = String::from("");
s.push_str("hello string");
let s2 = s; // 这里不是基本类型的简单赋值，是所有权转移
println!("s2 is {s2}, end");
println!("s is {s}, end"); // 这里会报错
```

为什么呢？首先s在栈上存了堆的地址，这个地址实际上包含了3个部分：字符串值在堆的地址，长度，占用空间，注意长度是这个字符串值当前的长度，而占用空间是虚拟机给它分配的可以用到的最大空间，如果字符串操作导致长度超出了占用空间，虚拟机就要重新找一块地方给它分配更大的空间，也就是会有一定的性能开销。

其次，如果按照基本类型的赋值去理解，**当s赋值给s2时，并不是在堆空间赋值了一份s关联的堆空间的值，而是仅仅把地址，长度，占用空间进行了复制**，那么就会出现一个问题，同一个堆上的值，有2个变量对其拥有所有权，**那么当任何一个变量离开了它的作用域时（s2不一定和s处于同一个作用域），是不是都要销毁对应的堆空间**？比如：

```rust
let s2:String;
{
    let mut s = String::from("");
    s.push_str("hello string");
    s2 = s; // 如果这里是让s2也变成所有者，那么当执行到s的作用域外侧时，s消失，s2会如何？
    println!("s is {s}, end");
}
println!("s2 is {s2}, end");
```

这样的设计会带来2个明显的问题：

1. 如果后续还要用到s2，那么s2的值因为已经销毁了所以不能再用
2. 反复释放同一个空间会导致BUG

所以RUST规定，当出现复合类型的赋值行为时，视为所有权的转移，即`let s2 = s;`**视为s放弃对它原本持有的地址和堆空间的值的所有权，这些都通通转移给了s2，s2是新的所有者**，也因此，s什么都没有了，它也就视为走到了生命周期的尽头，该销毁了。

既然s会在所有权转移时被销毁，那么这段代码也会**$\color{#DC143C}{报错}$**：

```rust
let mut s = String::from("");
s.push_str("hello string");
let s2 = s; // 这里s就销毁了
println!("s is {s}, end"); // 因为s销毁了，所以不能再被其他代码调用
```

这里RUST会提示borrow of moved value，即变量s在所有权转移后仍被别的代码借用。所以在RUST中不要随便赋值，如果是复合类型，一定会发生所有权的转移，从而终止原变量的生命周期。



##### 所有权和复制行为

**基本类型之间的赋值，本质是复制**，因为值都是存于栈上，大小已知，且一般都很小，复制起来性能开销也少。

复合类型之间的赋值是所有权转移行为，会导致旧变量的生命周期终结。但一些复合类型提供了对应的方法，以满足特殊场景下的需要，比如字符串就有一个实例方法叫`clone`，用法如下：

```rust
let s2:String;
{
    let mut s = String::from("");
    s.push_str("hello string");
    s2 = s.clone(); // 这里所有权没有转移，是真的在堆上复制了一份，所以s2持有的地址和s是不同的
    println!("s is {s}, end"); // 因为s的所有权没有转移，所以这里是正常的
}
println!("s2 is {s2}, end");
```

复合类型里面有集合类型tuple（有限复合集）和数组，两者其实也实现了复制，前提是它的元素都必须全部是基本类型，比如：

```rust
let tup1: (i32, i32) = (1, 2);
let tup2 = tup1; // 都是基本类型，所以也是复制
println!("tup1 is {}, {}", tup1.0, tup1.1);

let arr1 = [1; 2]; // [1,1]
let arr2 = arr1; // 这里也是复制，因为元素都是基本类型
println!("arr1 is {}, {}", arr1[0], arr1[1]);
```

**所有的函数传参本质都是赋值，把值传递给了形参**，具体是复制还是所有权转移，根据具体的参数类型确定，比如：

```rust
let s3 = String::from("haha");
move_example(s3);
println!("s3 is {s3}, end"); // 这里会报错

fn move_example(a: String) {
    println!("param ownership is moved"); // 即使函数内没有用到入参，所有权还是转移给了形参
}
```

上述代码中，move_example因为把值转移给了形参，而形参的作用域就是函数本身，因此函数执行完成后，形参就被销毁，值也一样。

**所有函数的返回值本质也是赋值**，这个更好理解，如果返回的是基本和其相关类型，就是复制，如果返回的是字符串，就是所有权转移。



##### tuple和数组的默认行为

tuple是一种特殊的Struct（结构体），这个在后面会提到，这里简单说一下，因为tuple可以包含多种类型，如果强制要求tuple类型或者数组类型只能是赋值导致所有权转移，那么在编程实践中会比较麻烦，比如数组过长的时候，取得其中的某个下标，或者要求修改某个下标，在结合第三方库的情况下开发都会很困难，所以RUST做出了一个决定，**当tuple内所有元素，单独拎出来进行赋值都是复制时，那么tuple自身的赋值也就是复制，数组也有对应特性**，比如：

```rust
let tup1: (i32, i32) = (1,2);
let tup2 = tup1; // 这里是复制
println!("tup1 is {}, {}", tup1.0, tup1.1);

let arr1 = [1; 2];
let arr2 = arr1; // 这里也是复制
println!("arr1 is {}, {}", arr1[0], arr1[1]);
```

反过来，如果tuple内包含了具有所有权机制的元素时，tuple自身的赋值就是所有权转移了，数组也是类似。

**tuple和数组默认都是存在于栈上**，因为编译时大小已知且不能更改，当然如果它们包含的元素是大小未知的，处理也是类似，只会保存地址，具体的值还是在堆上。



##### 引用和借用中

首先它们不是同一个概念，RUST设计这个机制就是为了解决不能随意赋值的问题，当然在不违反所有权原则的前提下。

既然复合类型的所有者持有了堆地址，而且无法轻易转移，那么把这个所有者在栈里面的地址也当作一个地址就可以，这个就是引用的概念，即：

```
引用变量 => 栈里面的所有者 => 堆内的值
```

引用就是二次地址，**即所有者的堆地址在栈内保存的地址**，使用`&`符号来表示，比如函数传参的问题，可以把入参替换为引用类型：

```rust
let s3 = String::from("haha");
let size = get_str_size(&s3);
println!("s3 is {s3}, length is {size}");

fn get_str_size(a: &String) -> usize {
    return a.len();
}
```

String的引用型就是`&String`，变量s的引用就是`&s`，以此类推。

也可以把引用赋值给其他变量，比如：

```rust
let s = String::from("haha");
let s_ref = &s;
let s_ref2 = s_ref; // 这里不会导致所有权的转移，因为s_ref自身并没有所有权，但是会导致增加了2个借用者
println!("{s_ref}, {s_ref2}");
```

这种从一个所有者变量中创建一个引用变量的行为，就叫做借用，**更精确的说法是把所有者添加了”借用中“这一状态**。为什么直接不说借用？而是用**添加了借用中的状态**这一更复杂的说法？虽然引用不会破坏现有的所有权状态，但是它会带来生命周期的问题，就上述代码而言，s_ref和s的生命周期应该是如何的？显然，s_ref，即**借用者，必须要活在被借用者，即所有者的生命周期内**。而反过来，当要销毁一个所有者的时候，必须确保它没有`借用中`这一状态，即所有基于它的借用者（引用变量），都要在它之前销毁，比如：

```rust
let s4 = String::from("owner");
let s5 = &s4;
move_ownership(s4); // 这里就会报错
println!("s5 is {s5}");
```

上述代码为什么报错？考虑下两者的生命周期就好理解了，s4是所有者，s5是对其的引用，导致s4加上了借用中的状态，s4的生命周期在进入move_ownership后就结束了，但是后续一行依然再调用s5，显然s5的生命周期要长于s4，这是不被RUST允许的，因此当s4销毁时，s5必须在更早的时候销毁，否则编译器会提示cannot move out of xxx because it is borrowed，所以RUST里面的借用，应该这样理解：

- 给被借用方，一般是所有者，添加了借用中的状态
- 可以给同一个所有者创建多个引用，即添加多个借用中的状态
- 所有引用的生命周期都必须被包裹在被借用方的生命周期内
- 被借用方销毁，或者其地址发生变化后，禁止和它有关联的引用者继续存在

所以**一般写引用的时候都不会显式地赋值给变量**，而是直接`&`符号引用，这样的好处是用的时候才创建引用，用完了变量离开它的作用域自然就销毁了，也就不会影响到所有者。



##### 可变引用

可以把借用中理解为现实中的名片卡，卡主人对名片上的信息具有完全的修改权（所有者），卡主人可以向多人分发自己的名片卡，但是如果卡主人更换了手机号（堆内存地址），则拿到这些名片卡的其他人，通过旧的信息是找不到卡主人的，所以RUST要求卡主人更换手机号之前，要确保之前分发出去的名片卡，不再被使用。（引用变量的生命周期要在所有者的生命周期之内）

但是业务上经常又会要求开发者能对引用变量进行修改，这意味着**需要让所有者进一步放权**。RUST在这里是这样设计的：

- 所有者不需要转移所有权，因此对值的生命周期有完全的掌控，**引用者无法干涉所有者的生命周期**
- 为了让引用者可以修改，所有者需要让渡值的修改权
- 为了避免多方引用者修改值，在任意时间切面上，只允许存在1个具有修改权的引用方，或者多个不具有修改权的引用方

举例：

```rust
let mut s4 = String::from("owner");
let s5 = &mut s4;
println!("borrowed {}", &s4); // 到这里就报错了，因为可变引用的生命周期还未结束
s5.push_str("ship");
println!("s5 is {s5}");
```

通过`&mut foo`创建可变引用，需要所有者让渡修改权，因此所有者也必须用`mut`修饰。

上述代码，可变引用s5的生命周期持续到了最后，因此在中间任意时间切面上，不允许其他引用者存在，只允许可变引用s5存在。

如果需要添加多个不可变引用，或者新的可变引用，代码都要放到s5可变引用的最后一次调用之后。

RUST给可变引用设计的规则，还是可以用名片卡的例子来解释。卡主人拥有名片卡，卡上有一个打印好的手机号（初始的内存地址），然后卡片发给其他人。当卡主人需要修改手机号时，首先他确保了之前分发出去的卡都没有再使用，其次他让一位管家进行了修改（可变引用负责修改数据），最后再把修改后的卡片又分发了出去。



##### 字符串切片

由于字符串本质是一个不限长度的数组，因此具有子数组的概念，所以可以通过切片写法来创建`&str`，即字符串切片类型，写法如下：

```rust
let a = "hello rust"; // 对所有写死的字串都是字符串切片类型
let b = String::from(a);
let c = &a[3..8];
println!("{c}"); // 输出lo ru
```

RUST把所有硬编码的字串都存到了二进制文件只读区域，相关变量都视为从这些区域读取的字符串的完整截取，因此还是`&str`，所以它们不可更改（这里的更改不是mut那种，而是不可继续拼接）。

字符串切片和字符串的区别如下：

- 字符串是完整的类型，可以修改
- 字符串切片是引用类型，而且是字符串的子数组，不能修改

**因为字符串切片是引用类型，所以它的生命周期还是受制于所有者的生命周期**，所以这种代码还是会**$\color{#DC143C}{报错}$**：

```rust
let a = String::from("hello rust");
let b = &a[3..10];
move_ownership(a); // 这里就报错了，因为b的生命周期比它的所有者a更长
println!("{b}");
```

还可以通过`&foo[a..b]`这种写法来表示一个子串，其中a和b各自表示开始和结束下标，b不包含。**既然是下标，就会有数组越界的问题，b的值不能超过字符串的最大长度**。

当开始下标是0时，可以省略，以下写法等价：

```rust
let a = String::from("hello rust");
let b = &a[0..3]
let c = &a[..3];
```

当结束下标是字符串最末尾时，也可以省略，以下写法等价：

```rust
let a = String::from("hello rust");
let b = &a[3..10]
let c = &a[3..];
```

所以`&a[..]`这种开始结束下标都省略的写法就表示对字符串进行完整的截取，当然类型还是`&str`，和`&a`类型是`&String`还是有区别。

字符串切片在实际编程内的用处很大，因为很多场合下需要对变量进行反复地修改以及重新赋值，如果都用&String处理则所有权规则会导致可变引用和不可变引用的编写麻烦，反过来如果都用&str来处理，那么第1，所有权没有变化，不会产生副作用；第2，操作的都是下标，性能更好。因此**推荐在函数声明入参中，需要字符串的时候，尽量用&str来代替**。

对于形参是&str的，传入&String会自动转换。



##### 宏命令的赋值行为

为什么println!可以直接传入字符串，而不用担心所有权转移的行为？因为它是一个宏（macro），不是一个函数。**宏的意思是元编程**，即println!()会在编译后转为一个正常的打印函数，而在那个函数内，它对入参做了处理，如果传入的是所有权变量，会统统转为`&`引用，所以println!宏最后生成的函数，是传入了引用变量，所以不会发生所有权转移的行为。

RUST里面还有其他的宏命令，**不是所有宏命令都会自动把所有权转换为引用，需要使用时单独确认**。



#### Struct（结构体）

RUST中的结构体从形式上有点像面向对象里面的类的概念，或者接口，具有极强的类型定义和校验的能力，实践中，一个完整的程序会需要大量自定义结构体来完成。

注意，**匿名tuple（也有具名tuple）是一种特殊的结构体，RUST对它做了一些增强**，因此在某些场景下（比如全都是基本类型的tuple，可以自动实现复制）我们**自定义的结构体如果需要达成和tuple一样的特性，还是要手动实现**。



##### 声明结构体

和面向对象类语言中，声明类或者接口类似的写法，**名称采用`UpperCamelCase`，即首字母大写的驼峰命名规范**，举例：

```rust
struct BodyCondition {
    height: u8,
    weight: u8,
}

struct User {
    name: String,
    age: u8
}
```

注意`struct`是关键字，最后一行逗号可加可不加。此外，struct可以直接声明在模块根节点，可以在根节点的任意位置：

```rust
struct Foo {}

fn main() {
    // do something
}

struct Bar {}
```

然后基于结构体可以创建对应类型的变量，比如：

```rust
let user1 = BodyCondition {
    weight: 10, // 具体构造时成员变量的编写顺序随意
    height: 120,
};
let u1 = User {
    name: String::from("Arc"),
    age: 10
};
```

注意上述代码中的BodyCondition，**虽然它的所有成员类型都是基本类型，但它还不能实现复制**，因此赋值会发生所有权转移，如果要实现复制，还需要手动添加代码。

获取成员变量依然是采用`foo.bar`形式，和tuple一样，也可以说tuple是有成员变量的，名称是0，1，2，3等等。

**可变`mut`关键字只能用来修饰一个完整的结构体变量**，不能单独用来修饰它的成员变量，所以即使只希望对一个成员变量进行改动，整个结构体变量也必须要可变：

```rust
let mut u1 = User {
    name: String::from("Arc"),
    age: 10
};
u1.age = 20;
```

结构体还有一些简写的方法，比如当值对应的变量名称和成员变量的名称相同时，可以简写：

```rust
struct Voter {
    name: String,
    age: u8
}
fn register(name: String, age: u8) -> Voter {
    Voter {name, age} // 这里直接用一个表达式返回一个构造的结构体变量，采用了简写
}
```

或者需要从结构体变量A构造出结构体变量B，因为两者类型相同，只是需要在关键的值进行修改时，可以用`..foo`表示其余的部分按照结构体变量A处理，举例：

```rust
let s1 = Student {
    school: String::from("MIT"),
    grade: 1,
    name: String::from("Bob"),
    age: 19
};
let s2 = Student {
    name: String::from("John"),
    ..s1 // 这行要放到最后
};
println!("s1 school is {}", s1.school); // 注意这里会报错，提示borrow of moved value
    
struct Student {
    school: String,
    grade: u8,
    name: String,
    age: u8
}
```

注意使用`..foo`写法，**在默认情况下是赋值操作，如果结构体没有特殊处理，会导致成员变量的所有权转移**。所以一般会给结构体加上copy和clone特性以支持简单的赋值创建新的变量，这个特性部分后面会提到。

还可以像声明tuple那样声明结构体，此时的tuple也会失去RUST给它添加的特性，即全是基本类型时也不能随意复制：

```rust
struct ColorRGB(u8, u8, u8);

let c1 = ColorRGB(10,10,10);
```

结构体一般是用于保存数据的，但和其他面向对象的设计思路类似，它也可以规定行为，所以在某些场景下，可能只需要它的行为，而非它的数据，那么就可以使用Unit-Like Struct（原子化结构体）来定义一个空结构体，并后续给它定义方法，比如：

```rust
struct Sortable;

impl Sortable {
    fn sort(&self) {
        println!("sorted to ascending order");
    }
}

let arr = Sortable; // 因为没有数据所以连大括号都可以不要了，加上空的大括号{}也可以
arr.sort();
```

到此这个结构体就带有一点特性的味道了。



##### 结构体的方法

RUST内，**函数（functions）和方法（methods）是两个概念**。

函数就是指一般意义上的函数，可以有入参也可以没有入参，可以有返回值也可以没有返回值，可以在根节点声明也可以在函数内声明。

**方法是特指给结构体 / 枚举 / 特性定义的行为**，枚举和特性后面会提到，**方法必须要定义在上述结构的内部**，**而且首个形参，名称必须是`self`（相当于self也是关键字）**，类型根据定义所在的结构体 / 枚举 / 特性确定，一般是调用此方法的变量的引用，方法可以有返回值也可以没有。

方法声明和使用举例：

```rust
let mut rect1 = Rectangle {
    width: 10,
    height: 30
};
rect1.set_height(10);
rect1.set_width(20);
println!("rec1 area is {}", rect1.calc_area());

struct Rectangle {
    width: u32,
    height: u32,
}
impl Rectangle {
    fn calc_area(self: &Rectangle) -> u32 {
        self.width * self.height
    }

    fn set_width(self: &mut Self, new_width: u32) {
        self.width = new_width;
    }

    fn set_height(&mut self, new_height: u32) {
        self.height = new_height;
    }
}

```

使用`impl`关键字给结构体添加方法，方法声明还是以`fn`开头，方法名称任意，第一个形参必须是self，**类型只能是结构体类型，或者对其的引用**，如果是结构体类型，那么和函数一样会发生所有权转移，除非返回所有权不然不建议，一般都是使用引用类型，所以这里也可以简写为`&self`（`self: &Self`的简写），最后是确定返回类型和方法体。

`Self`是一个特殊的类型，用在结构体内，表示当前结构体这个类型，不是指代当前的调用者，**因此一个方法可以传入多个类型是`Self`的，表示用多个类型相同的结构体进行合并运算**，比如：

```rust
struct Location {
	lat: f64,
	lng: f64
}
impl Location {
    fn relative_direction(&self, other: &Self) -> Direction { // 这里省略Direction的枚举定义
        // 两个坐标比较，确定第二个在第一个的什么相对位置
    }
}
```

如果需要修改结构体变量，则方法第一个入参必须是`&mut self`，当然它是`self: &mut Self`的简写，结构体变量本身也要用mut修饰才能使用这些修改的方法。

方法名可以和成员变量的名称相同，RUST可以通过是否加括号`()`来判断当前是方法调用还是访问成员变量。一般会在getter的场合用到，**结构体的成员变量默认是私有的，模块之外无法访问**，所以可以通过暴露getter的方式进行成员变量访问的拦截操作。

`impl Foo {}`这种写法可以声明多次，一般没有必要，但是如果希望对第三方库的结构体做进一步增强，可以结合特性一并使用。



##### 结构体的关联函数

在结构体中定义的方法，但是首个入参却不是`&self`，或者`self`（即`self: Self`）的，就被视为结构体的关联函数，它们在使用上和面向对象中的静态方法类似，比如`String::from`就是一个关联函数，使用时必须要通过`Foo::bar`的写法，即直接和结构体绑定，不和结构体的变量绑定，也无法通过结构体的变量使用，所以一般都会用于写构造函数，或者结构体特有的工具方法，比如：

```rust
struct Rectangle {
    width: u32,
    height: u32,
}
impl Rectangle {
    /// 构造函数1
    fn square(distance: u32) -> Self {
        Rectangle {
            width: distance,
            height: distance
        }
    }
	/// 构造函数2
    fn rect(height: u32, width: u32) -> Self {
        Rectangle { width, height }
    }
}

let rect1 = Rectangle::square(10);
let rect2 = Rectangle::rect(10, 20);
```



##### 一个特性和2个宏的用法（这段后续放到特性那部分，然后再补充一些内容）

正常使用println!宏是无法直接输出结构体的，会报错，提示需要实现display特性或者使用`:?`来输出，进一步使用`:?`会提示需要加Debug特性，这里就产生了一个概念，叫Derived Traits，即可推导的特性，简单写法是这样：

```rust
#[derive(Debug)]
struct BodyCondition {
    height: u8,
    weight: u8,
}

let user1 = BodyCondition {
    height: 120,
    weight: 10
};
println!("user1 is {user1:?}"); // user1 is BodyCondition { height: 120, weight: 10 }
```

当结构体加上了Debug特性后，还可以使用`dbg!([expr])`的方式来进行调试，这个宏有2个特点：

- 会拿走所有权，因此如果传入带有所有权的变量，推荐使用引用写法
- 生成的函数执行结果是返回这个变量，因此也可以通过赋值的方式拿回所有权

用法：

```rust
let user1 = BodyCondition {
    height: dbg!(120 * 2),
    weight: 10
};
dbg!(&user1);

#[derive(Debug)]
struct BodyCondition {
    height: u8,
    weight: u8,
}
```

dbg!宏命令，在需要观察数据结构，或者计算结果的时候，会比较管用。



#### 枚举和常用场景

RUST内对枚举的定义和其他编程语言类似，就是一组可枚举可穷尽的变量，除了常规自定义的枚举外，RUST还提供了一个`Option`枚举用于表示可有可无的值。



##### 声明枚举

以贪吃蛇游戏为例，用户输入的方向只能是上下左右其中一个，所以这样定义枚举：

```rust
enum InputDirection {
    Up, Left, Down, Right
}

// 入参类型限定为枚举
fn user_input(input: InputDirection) {
    // do something
}
```

以关键字`enum`开头，建议声明在根节点，枚举类和枚举值都用UpperCamelCase规范，和结构体一样。

注意，枚举和结构体一样，**本质是创建一套数据类型**，和结构体不同在于它的可能值的类型是确定的，但是因为这些可能值具有拓展性（后面会提到，枚举值是一个盒子，里面可以装其他的值），所以在堆栈处理上会有一些复杂。

使用枚举值采用`Foo::Bar`写法，比如：

```rust
let a = InputDirection::Up; // a具有所有权
let b = a; // 这里所有权转移了
println!("{b:?}"); // 这里输出a就会报错

#[derive(Debug)]
enum InputDirection {
    Up, Left, Down, Right
}
```

此外，枚举类默认不实现Copy特性，所以**每个值绑定的变量默认是具有所有权的**，就上述简单的枚举类型来说，每调用一次`Foo::Bar`，就会在栈上创建一个变量，虽然它们最终是相等的，但因为没有Copy特性所以声明多次就会创建多个变量，这也复合RUST一贯传统。

实际编程中，经常会遇到这样的场景，需要**定性的同时也能定量**，比如一个品牌推出了3种商品，通过电子系统搜集调查问卷，这里就会要求被调查者选择喜欢哪类商品（或者完全不喜欢），以及如果喜欢，购买频率如何，所以RUST给枚举添加了一个封装其他类型变量的功能，就这个调查问卷的例子，可以这样设计：

```rust
// 新商品市场调查
enum NewProductPoll {
    Item1(u8), // 商品1和购买频率
    Item2(u8), // 商品2和购买频率
    Refuse(u8, String) // 不会购买，因此频率固定是0（还是要存一下），并希望访问者给出原因
}

let poll1 = NewProductPoll::Item1(10);
let poll2 = NewProductPoll::Item2(5);
let poll3 = NewProductPoll::Refuse(0, String::from("not a fan"));
```

这样通过用户的交互就可以搜集到对应数据，便于后续分析了。

注意这里Refuse是一个类似tuple的结构，封装了数字和字符串，**因此数字的部分，和字符串的内存地址，都会存于栈上**，而字符串本身会存于堆内。

上述例子还说明了**同一个枚举类内的值，可以包含不同的数据类型**，但显然这会带来问题，当需要判断具体是哪个值的时候，还需要根据这个值包含的数据类型做进一步处理，这个就要用到后续提到的模式匹配（pattern matching）了。

RUST不仅允许枚举值声明类似tuple的结构，还允许声明类似结构体的结构，比如：

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 }, // 这里的类型很像结构体
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

这样的好处是一些简单的结构可以直接被包含在这个枚举类的定义内，而不需要为每个值单独声明一个tuple或者结构体。

枚举还可以像结构体那样定义方法，写法也是类似：

```rust
enum NewProductPoll {
    Item1(u8), // 商品1和购买频率
    Item2(u8), // 商品2和购买频率
    Refuse(u8, String) // 不会购买，因此频率固定是0（还是要存一下），并希望访问者给出原因
}

impl NewProductPoll {
    fn submit_poll(&self) {
        // 提交问卷调查
    }
}

let poll3 = NewProductPoll::Refuse(0, String::from("not a fan"));
poll3.submit_poll();
```



##### Option枚举类型和NULL值问题

RUST自带一个枚举类型叫Option，用于表示可有可无的场景，也用于替代NULL，**RUST里面没有NULL这个概念**。

空值问题一直是编程语言设计的难题，因为堆栈设计会导致引用变量的出现，而如何表示一个变量并没有任何引用，或者当需要手动销毁一个变量时，应该如何让GC去理解。这些问题使得设计者很容易就会想到用NULL这个概念去表示**没有任何引用**，但是如果任何变量都可以被赋值为NULL，那么其他语言中经常会出现这样的boilerplate代码：

```javascript
if (a !== null && a.b !== null && a.b.doSomething !== null) {
  a.b.doSomething();
}

a?.b?.doSomething?.();
```

这里的问题是因为所有变量都可能是NULL，所以当一个变量存在被反复修改的可能时（这个在MVVM设计下太常见了），每次调用都要进行NULL判断，如果百密一疏某个地方漏掉了，就会导致程序出现BUG或者CRASH。所以也有说法是NULL设计是一个十亿美元的错误（billion-dollar mistake）。

那么出问题的地方是哪？显然NULL这个概念的提出是没有问题的，因为确实需要在计算机中描述没有意义的场景，需要被销毁的场景，无任何数据的场景，有问题的是**任何一个类型的变量都可以随时转为NULL类型而没有任何预警措施这一设计**。所以需要给NULL设计一个类型，并且如果一个变量可能会成为NULL，则需要纳入到这个类型内，这个就是RUST的Option类型：

```rust
enum Option<T> {
    None,
    Some(T),
}
```

Option枚举类包含2个值，None和Some，其中Some用到了泛型。编写None和Some的时候不需要加`Option::`，因为RUST自动帮我们引入了Option枚举类。

Some和None的最简单用法如下：

```rust
let a = Some(5); // 默认是Option<i32>类型
let b: Option<i32> = None; // 注意赋值为None的时候还要显式声明一下如果不为None应该是什么类型
```

注意虽然a在编写时有具体的值，但它的类型依然是Option，即允许它未来可能没有值。

RUST通过`Option<T>`这一可有可无的概念，就和原本的`T`类型做了区分，在其他语言当中，一个变量可以是T类型，也可以是NULL类型，从T到NULL的转变不会有提示。而在RUST中，一个变量要么是T类型，要么是`Option<T>`类型，前者就是断言它不会为NULL，如果随意更改编译器也不会允许，后者就是断言它可能随时为NULL，因此它的所有操作都需要加入非空判断，**这样一来就区分了根本不可能为NULL的场景和可能为NULL的场景**，而且断绝了两者转换的机制，比如`Option<i32>`无法和`i32`类型进行数学运算：

```rust
let a = Some(5);
let b = 5;
let c = a + b; // 这里会报错
```

上述代码虽然a和b都是写死的值，在最简单的程序中它们也不会有后续变动，但RUST编译器就是禁止把两者混为一谈，以保证运行时不会出现十亿美元错误的问题。

从一个Option类型中取值，一般会采用`unwrap_or`方法，或者采用后续提到的模式匹配，前者方法会需要提供一个默认值，以避免取不到值的场景，比如：

```rust
let a = Some(5);
let b = 5;
let c = a.unwrap_or(0) + b; // 这里要从a取值，需要提供一个默认值
println!("c is {c}");
```



##### 模式匹配（pattern matching）

一般的编程语言，在流程控制上会提供switch--case这种写法，以实现把一个值（表达式）匹配到多个值中的其中一种，最后再用一个默认处理来结束的操作。**而RUST的模式匹配远比switch--case强大**，因为它不仅允许匹配多个值，更能允许模糊匹配，或者按照一定条件匹配，编写起来也远比switch--case灵活。所以，RUST里面没有switch--case语法，因为模式匹配就够用了。

最简单的例子，还是以贪吃蛇的方向为例：

```rust
enum InputDirection {
    Up, Left, Down, Right
}

fn move_snake(direction: InputDirection) -> (i32, i32) {
    match direction {
        InputDirection::Up => (0, 1),
        InputDirection::Down => {
            println!("snake go down");
            (0, -1)
        },
        InputDirection::Left => (-1, 0),
        InputDirection::Right => (1, 0)
    }
}
```

最简单的写法就是`match foo {}`，然后内部根据不同的值（实际上就是模式）返回不同的结果，或者加入代码块进行不同的业务处理，注意这里用的是`=>`连接模式和处理结果。

当然这么简单的逻辑也可以用if else处理，只不过写起来更麻烦（if的条件必须是一个boolean或者对应的表达式，如果match的是一个Option类型则用if处理就更麻烦了）。当然match能做到更多的事情，比如从枚举值中进一步取值，还是以之前的商品问卷调查为例：

```rust
let poll1 = NewProductPoll::Item1(10);
let poll2 = NewProductPoll::Item2(5);
let poll3 = NewProductPoll::Refuse(0, String::from("not a fan"));
poll1.submit_poll();
poll2.submit_poll();
poll3.submit_poll();

// 新商品市场调查
enum NewProductPoll {
    Item1(u8), // 商品1和购买频率
    Item2(u8), // 商品2和购买频率
    Refuse(u8, String) // 不会购买，因此频率固定是0（还是要存一下），并希望访问者给出原因
}

impl NewProductPoll {
    fn submit_poll(&self) {
        match self {
            NewProductPoll::Item1(freq) => { // 这里就是取值了
                println!("like item1, freq is {freq}");
            },
            NewProductPoll::Item2(freq) => {
                println!("like item2, freq is {freq}");
            },
            NewProductPoll::Refuse(_, reason) => { // 用不到的值可以用下划线代替
                println!("like no one, reason is {reason}");
            }
        }
    }
}
```

Option类型的处理，比如判断是否有值，如果有值，做进一步计算，例子如下：

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}
```

注意上述处理返回值也可以是i32，比如当为None的时候默认为0，加1返回1也是可以的。

如果有2个Option类型进行运算，如何进行match匹配？最简单的方法就是如果2个都有值，进行正常处理，其他情况下返回一个异常处理结果，举例：

```rust
let a = Some(5);
let b = Some(6);
let c: Option<i32> = None;
println!("a + b = {}", option_add(a, b).unwrap_or(0));
println!("b + c = {}", option_add(b, c).unwrap_or(0));

fn option_add(a: Option<i32>, b: Option<i32>) -> Option<i32> {
    match (a, b) {
        (Some(a), Some(b)) => Some(a + b),
        _ => None
    }
}
```

注意上述match的写法， 需要对多个值进行联合判断时，可以用类似tuple的写法，取值也是一样，还可以用`_`表示默认处理结果。



##### if let else可以替代简单的模式匹配

一个模式匹配必须涵盖所有场景，如果只是对一个值进行匹配还好，如果有多个值同时参与，要么枚举出所有的模式，要么用`_`代表其他情况。**在只需要匹配一个模式，并且自动忽略其他模式时，可以用if let写法来代替**，举例：

```rust
// 根据随机数初始化一个Option变量
let mut a: Option<i32>;
let r = rand::thread_rng().gen_range(1..=100);
if r > 50 {
    a = Some(r);
} else {
    a = None;
}
if let Some(val) = a { // 如果这个变量有值，做后续处理，否则不处理
    println!("a is valid, {val}");
} else {} // else可以省略
```

if--let--else中，else可以省略，表示其他模式下不处理，一般来说不建议写else或者else只写很简单的处理逻辑。

if let后面写的相当于match里面的模式，因此也可以匹配多个Option的值，举例：

```rust
let a = Some(5);
let b = Some(6);
let c: Option<i32> = None;
if let (Some(x), Some(y)) = (a, b) { // 这里如果改成是None的c，那么就不会执行下面的输出
    println!("a + b in if let is {}", x + y);
}
```

if let从语义上也很好理解，如果让【一组模式】等于【待匹配的变量】，则执行代码块内的语句。



#### 大项目的分割管理

代码多了都要进行分割管理，这个写过稍微复杂一点功能的都懂。RUST在处理代码分割上设计了一套概念，都是从大到小，直接采用集装箱的概念去理解就可以了，简单来说RUST的模块系统由以下要素构成：

- 货舱（packages，有些教程会翻译为项目，或者包，不合理），即一个完整的货舱（所以执行命令会用cargo run），也可以理解为一个项目，一般初始化项目，创建的就是package，**标志是根节点带有Cargo.toml配置文件**，货舱里面会有至少一个箱子。
- 箱子（crates，有些教程会翻译为包，更不合理），货舱内的箱子，一个箱子就是一个完整的可以直接拿走的部分，代码层面来说就是编译的入口以及其涉及到的代码 / 文件。比如对一个初始化的项目来说，一定会有一个src / main.rs文件，这个main文件就是入口，如果它内部引入了其他的文件，则这些文件和这个入口文件都会被视为同一个crate。一个货舱里面可以有多个箱子。
- 模块（modules），可以理解为单独的文件或者代码块，箱子内的物品，它的核心是把代码进行分割并默认隐藏，以限制外部能访问到内容，单独的文件可以是一个模块，也可以在一个文件内创建多个模块，甚至可以在一个模块内继续创建子模块。
- 路径描述（paths），即在模块之间沟通时，A模块描述B模块的方法 / 结构体 / 函数等的方式，即模块之间的沟通（调用）的方式



##### 货舱和箱子

货舱是一个整体，即一个完整的项目，一定会包含Cargo.toml文件，这个文件就和JS体系的package.json一样，包含了对项目的描述，以及所依赖的其他三方库等等。一般创建项目，都是用`cargo new [project_name]`，其他命令比如`cargo run`，`cargo build`等，都依赖CARGO，学习RUST的时候也是先要通过rustup-init去安装CARGO，还要配置一下环境变量以让上述命令可以被OS识别。所以**CARGO本身就是一个项目**，它的项目地址是[这里](https://github.com/rust-lang/cargo)，**我们用到的都是它编译之后的版本，所以看不到Cargo.toml文件，只有bin路径内的一堆可执行文件**，实际的源代码里面是有的。

一个货舱，需要至少包含一个箱子。箱子是RUST编译期需要处理的所有代码的整合，也即**可以被编译器完整处理的代码总和**。最简单的箱子就是新建项目时的main.rs，虽然只是一个hello world但也能编译为可执行文件。当然实践中箱子里需要包含不同的模块，一个好的箱子，应该把代码都分散到各个模块内，箱子入口的代码应该要尽量减少。

RUST规定箱子只能有2种类型，二进制（binary）或者库（library）。

二进制箱子约定的入口文件是`src / main.rs`，经过编译后可以转为可执行文件，当然包含了完整的代码。比如最简单的hello world，编译完成后，如果直接用鼠标双击执行，肯定是看不到效果的，但如果通过CMD命令把路径切到对应位置，通过`[foo].exe`命令执行的话，就可以看到CMD界面输出了对应的信息。所有的二进制箱子都必须以`main`函数作为入口，**入口文件名可以不是`main.rs`，但是函数名不能动**。

除了默认的`src / main.rs`入口外，还可以在`src / bin`路径下创建其他的入口，以生成多个可执行文件。

库类型的箱子约定的入口文件是`src / lib.rs`，当然也可以改入口，它不需要有`main`函数（有也没事，但是不会被视为入口），因为它是库，应该看作一个工具箱，内部有各种工具（各种类型，各种函数等等），对库箱子来说，重要的是把这些工具提供出去，让其他人来使用，比如之前随机数用到的rand，它虽然是以包的形式发布的，看源码可以找到Cargo.toml，但是重要的是它的入口lib.rs是作为一个库发布出去的。所以大部分时候，开发者提到crate，一般就是指这种第三方的库类型箱子。库箱子在编译后会生成`rlib`类型的文件。

实际上最简单的编写库类型箱子的方法，就是在src路径下创建一个lib.rs文件，然后随便写一个函数即可：

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

最后执行`cargo build`，就可以在target / debug路径下看到它了。

**一个货舱可以包含多个二进制箱子，但是只能有一个库箱子**。二进制箱子多个很好理解，不同的执行文件可以有不同的作用，比如一个负责CLI，一个负责自动化测试，一个负责开启服务等等，RUST之所以限制只能有一个库箱子，有以下考量：

- 避免使用者的歧义，减少使用者上手门槛，即开发者接触一个三方依赖时，可以清楚知道有哪些可执行命令，或者可以用到的库，由于库只有一个，不会出现在引入时需要选择的问题
- 强迫开发者组织好代码，把需要提供的工具以一个完整的形态展示出来



##### 使用模块控制作用域

**箱子里面可以不包含模块**，比如最简单的hello world项目，直接在main.rs里面编写代码就可以了，此时这个main.rs虽然是一个二进制箱子，但它不包含任何模块。

RUST对模块声明有以下约束：

- 必须使用关键字`mod`，没有任何一个模块是不需要这个关键字，就可以让编译器识别出来的
- 模块之间具有层级依赖关系，**最终需要确保所有模块溯源后能联系到箱子**
- 模块声明可以采用内联写法，也可以采用单独文件的写法
- 命名规范和一般变量一样，采用snake_case

先来一个简单的例子，在之前的分割文件教程里面，已经提到了最简单的分割方法，就是这样，在src路径下创建一个文件，比如demo.rs，那么main.rs里面这样写：

```rust
mod demo.rs;
```

由于所有模块都必须保证溯源后能联系到箱子，因此**RUST不会自动把任意源码文件都看作是一个独立的模块**，必须要通过和箱子main.rs关联才可以，**具体来说，就是在main.rs内通过`mod demo.rs;`告诉编译器，`src / demo.rs`是一个模块**。

之后在demo.rs内暴露一个方法出来，**RUST对所有模块默认采用私有策略**，即模块内的所有声明实体，默认都是私有的，除非显式地通过关键字`pub`把它暴露出来，所以要暴露一个方法，应该这样写：

```rust
pub fn run() {
    // do something
}
```

之后就可以在main.rs箱子入口的main方法内调用此模块暴露的方法了：

```rust
mod demo.rs;

fn main() {
    demo::date_util::date_format();
    demo::number_util::number_format();
}
```

RUST的模块解析策略是这样的，对`mod foo;`来说，RUST会尝试这样寻找模块：

- 在当前路径内，寻找`foo.rs`
- 在当前路径内，寻找`/foo/mod.rs`，此时**mod.rs就相当于JS体系的ESM模块内的index.js**

模块的内联写法也提一下，比如还是以demo.rs为例，它是一个模块，我们可以直接在它内部创建内联写法的模块：

```rust
pub mod date_util {
    pub fn date_format() {
        println!("date format");
    }
}

pub mod number_util {
    pub fn number_format() {
        println!("number format");
    }
}
```

注意内联模块默认也是私有的，如果要暴露出去也需要使用pub关键字，模块内的所有要素当然也默认是私有的。

这样以来结构就变成这样了，有一个直接和箱子关联的根模块，它内部还包含了2个子模块：

```
|---demo // 根模块
  |---date_util // 子模块1
    |---date_format()
  |---number_util // 子模块2
    |---number_format()
```

如果需要直接在demo.rs内调用，因为已经声明了对应模块，直接通过`date_util::date_format()`调用即可。

如果需要在main.rs内调用，则需要先从demo模块开始，写法是`demo::date_util::date_format()`。

另外RUST的模块解析策略也使得我们可以通过声明`src / demo / mod.rs`来实现把`date_util`和`number_util`分拆为单独的文件，或者整合到另外一个文件内，比如分拆文件的写法，就是：

```rust
// src / main.rs

mod demo.rs; // 这里是找到了src / demo / mod.rs

fn main() {
    demo::run();
}

// src / demo / mod.rs

mod date_util; // 找到了src / demo / date_util.rs
mod number_util; // 找到了src / demo / number_util.rs

pub fn run() {
    date_util::date_format();
    number_util::number_format();
}


// src / demo / date_util.rs
pub fn date_format() {
    println!("date format");
}

// src / demo / number_util.rs
pub fn number_format() {
    println!("number format");
}
```

当然也可以把这2个子模块整合到一个文件内，比如叫util.rs，那么在mod.rs内只需要通过声明`pub mod util;`就可以了，此时调用写法就会长一些，比如`demo::util::date_util::date_format()`。

既然所有模块最终都要溯源到根模块，那么假设有一个和demo模块平级的，比如task模块，就可以这样调用demo模块内的子模块的方法：`crate::demo::util::date_util::date_format()`，即以`crate::`开头表示从根箱子开始定位对应模块。

还可以结合`use`关键字还省略每次从`crate::`开始写，比如在task模块内：

```rust
use crate::demo::util::date_util;

pub fn run() {
    date_util::date_format();
}
```

这里的`use`就类似其他语言的import语法，即在当前作用域内指明对应模块的简写。



##### use和pub的补充说明

use除了引入项目内模块时，也通常用于引入第三方依赖，比如之前的猜数字游戏，就用到了rand库，引入写法是这样的：

```rust
use rand::Rng;
```

引入多个库时，如果它们的部分前缀相同（即模块树的一部分是相同的），则可以这样写：

```rust
use std::{cmp::Ordering, io};
```

相当于：

```rust
use std::cmp::Ordering
use std::io;
```

一般IDE会自动帮我们处理这部分写法。

还有比如需要引入A模块，以及它的子模块B，则会这样处理：

```rust
use std::io;
use std::io::Write;

// 以下写法等价
use std::io::{self, Write};
```

**可以使用`use foo as bar`来处理别名**，比如有2个use的场景，最后的模块名称相同，则可以用`use crate::demo as demo1; use crate::util::demo as demo2`来区分。

`pub`关键字不仅可以暴露模块，方法，也可以暴露枚举类，结构体等等。**对于结构体的成员变量，如果不使用`pub`，默认也是私有的，因此可以通过只暴露结构体方法，不暴露成员变量的方式，来防止外部随意修改成员变量值**。给枚举类加上`pub`后，其所有的值都会被暴露，不需要再单独添加。

**pub和use可以结合使用**，即`pub use crate::foo:bar`，此时不仅在当前作用域内可以直接使用`bar::`的各种要素，还相当于把它也暴露了出来，外部也可以使用它。



##### 模块间路径描述

在A模块内如果想用到B模块暴露的方法，上文已经提到过，可以用`crate::`开头来进行绝对路径描述写法，这种写法好处是它不需要考虑当前文件所在的位置，即使移动了也可以用，如果觉得每次调用太麻烦还可以用`use`关键字声明为简写。

还有一种路径描述写法，即相对路径描述，比如在main.rs内的所有根模块，彼此之间互相调用时，并不需要加`crate::`，因为它们都是兄弟模块，可以省略，这个就是一种相对路径描述，还可以使用`super::`开头来表示当前代码所在模块的上一级模块，举例：

```rust
fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order(); // 这里用到了super关键字，表示当前代码所在模块的上一级模块
    }

    fn cook_order() {}
}
```



#### 常用集合类型

RUST标准库（就是通过`use std::foo`引入的）包含了一堆实用性很强的集合类型，不像数组（array），它们都是存于堆上，因此具有可变大小的特性。这里介绍的常用集合有：

- vector（可变数组），顾名思义，就是不定长的数组。
- String，字符串，对，它也是集合，因为它存于堆上
- hash map，也叫哈希表，一般编程语言里面都有这个概念，它是map（映射表）这个数据结构的衍生



##### 可变数组

vector的类型其实是`Vec<T>`，即它是一个支持泛型的可变数组，既然是数组，从数据结构上看**运行时会分配一堆连续的内存空间（其元素还是按照基本类型直接存储，复合类型只存地址的设计）**，所以扩容时会重新分配内存空间。

此外，泛型参数只有1个，也说明可变数组只能存储一种数据类型。

声明可变数组的写法：

```rust
let vec1: Vec<i32> = Vec::new(); // 正常写法
let vec2 = vec![1,2,3,4]; // 使用宏的写法
let vec3: Vec<i32> = vec![]; // 虽然是宏写法但是没有给出元素，因此还是要加上类型声明
```

使用正常写法必须声明数据类型，宏写法时如果有默认元素，则RUST可以基于已知元素进行类型推断。

数组的操作，既然是可变的所以也需要通过`mut`关键字修饰后才可以更改，比如：

```rust
let mut vec1: Vec<i32> = Vec::new();
vec1.push(1);
vec1.push(2);
if let Some(last_ele) = &vec1.pop() { // 通过pop可以拿到最后一个元素，当然是Option类型
    println!("{last_ele}, {vec1:?}");
}
println!("{vec1:?}");
```

其他数组操作涉及到闭包知识点，后续提到闭包后再补充，先记住push是新增，pop是移除最后一个。

数组访问的方式有2种，一种是直接下标写法，即`foo[index]`，还有一种是采用`foo.get(index)`写法，会返回之前在枚举内提到的Option类型，举例：

```rust
let mut vec1 = vec![1,2,3];
let first = vec1[0]; // 这里不会发生所有权转移，因为存储的是基本类型，所以直接是copy操作
println!("{first}");
if let Some(_) = vec1.get(1) {
    vec1[1] = 10; // 确认能访问到就可以直接通过下标进行替换
}
```

注意直接通过下标访问元素并赋值时，必须要确认不会出现数组越界的问题，此外可能会发生所有权转移，因此统一用`&`符号是比较好的习惯，通过`get`方法本身拿到的是`Option<&T::Output>`类型，即使数组越界也没事，此外如果不越界，取到的已经是引用了，所以赋值给变量也没事。

数组越界访问会触发panic（即异常终止），在某些业务场景下可能希望系统就这样终止，而get越界不会触发panic，只会拿到None，从而把问题抛给开发者处理。

还有一个注意的点，**数组元素都是存于堆上的连续空间，对外只暴露这个空间的开始位置**，所以`&vec1[0]`它表示的是可变数组`vec1`的堆地址在栈内保存的位置和希望访问的下标，并不是直接保存这个下标元素实际在堆的地址，因此`&vec1[0]`是**直接给数组整体添加了借用中的状态**。既然是可变的因此只要操作了元素就可能出现重新分配堆空间的问题，因此和String一样，**在修改数组之前，需要保证所有的借用者都销毁**，仅仅只能保留一个可变引用。

数组变量本身具有所有权的概念，其元素的所有权默认归数组管理，因此也就和它绑定的变量一同存在，即**声明一个数组，不仅获得了数组本身的所有权，也获得了其内部所有元素的所有权**。如果要单独抽离出某个元素的所有权，在RUST设计者看来，就会出现**一个数组，和其内部元素所有权不一致的情况**，会导致各种问题，因此RUST认为，**可以把其内部元素的所有权转移走，但同时这个元素也必须被处理或者替换为空占位（不是None，而是替换为一个默认值），即需要一直维持数组本身和其元素的所有权一致的状态**。

一个简单的转移所有权的例子，可以看出RUST设计数组的思想：

```rust
let vec2 = vec![String::from("ab"), String::from("cd")];
let ele1 = vec2[0]; // 这里就报错了，禁止直接转移单个元素的所有权，因为String没有copy特性

let mut ele2: String;
for ele in &vec2 {
    ele2 = *ele; // 这样写也会报错，禁止单个元素的所有权转移，*符号是解引用
}
```

所以，基于所有权一致的原则，**当一个数组的所有者销毁时，其绑定数组和内部所有元素也会随之销毁**。

数组遍历，和之前的不可变数组一样，直接使用for in写法，**建议数组的部分采用引用写法，因为默认的for in会导致所有权转移**：

```rust
for ele in vec1 { // 这里就把数组和其元素的所有权都转移走了
    println!("ele is {ele}");
}
println!("{vec1:?}"); // 这里会报错
```

反过来对数组的部分采用引用写法（for ele的部分不用，ele的类型由for ele in [vec]，即数组写法是引用还是所有者变量确定），就能保证遍历时所有权不发生转移：

```rust
for ele in &mut vec1 { // 遍历时要修改元素，因此要采用可变引用
    *ele *= 2; // 这里用了*符号表示解引用, *=表示 *ele = *ele * 2
}
println!("{vec1:?}");
```

`*`符号表示解引用，更贴切的说法是**指向真实地址**，即基于数组所有者在栈内的地址，找到这个元素在堆内的实际地址。

RUST禁止在遍历时新增或删除元素，编译器会直接报错。

此外还可以**通过传入枚举类型，来支持在数组内存储多种类型的数据**，因为不同的枚举值允许包裹不同类型的数据。



##### 数组常用操作

这块放到最后学习了RUST内的闭包之后再补充。需要补充增加，删除，修改，替换，排序，查询等等。



##### 用字符串存储UTF-8编码信息

在RUST中，字符串本质是字节的集合，比如一个汉字一般是3个字节，所以一个汉字构成的字符串，就是包含3个字节的数组。也因此字符串的操作如果考虑到UTF-8编码，就会比一般语言内的字符串操作更复杂一些。



##### String类型的定义

RUST语言的核心部分，只有`str`类型，即存储于二进制文件的静态数据区域，只能读取不能修改的数据，代码中写死的字串都是`&str`类型，即对这个原本的`str`类型的引用。

String类型是RUST标准库提供的，表示可以修改，可以扩容，且以UTF-8编码的字符串类型。`str`类型也是UTF-8编码。



##### 字符串常用操作

字符串也是集合，因此也可以使用new方法构造，或者从字串切片转过来，一般方法有：

```rust
let str = String::new();

let str = String::from("default");

let str = "default".to_string();
```

`String::from()`和`"str".to_string()`是等价的，可以自由选择。

字符串拼接的方法较多：

```rust
let mut str = "default".to_string();
str.push_str(", another"); // 传入&str类型
str.push('!'); // 传入char类型
println!("str is {str}");

let str2 = String::from("second");
let str3 = str + &str2; // 注意字符串相加会被编译器转为add方法，此方法要求第二个入参是&str类型
println!("str3 is {str3}");

let id = "123".to_string();
let name = "Arc".to_string();
let list_item = format!("[{id}]-{name};"); // 会输出[123]-Arc这样的格式
println!("{id}, {name}, {list_item}"); // format不会导致所有权转移
```

注意字符串相加实际上是调用了add方法，所以第二个入参需要是`&str`类型，**`&String`会被自动转为`&str`**，`format!`宏是一个非常强大的字符串拼接加格式化工具，而且**它不会导致所有权转移**，因此在需要对字符串进行分块处理后再合并的场景，建议使用`format!`。

由于RUST中，字符串的本质是字节流，我们看到的只是UTF-8编码后的结果，因此**直接通过`string[index]`下标访问，尝试获取单个文字或者符号，是不行的，编译器禁止这种行为。**

如果硬要像其他语言那样直接访问某个下标，则需要告诉RUST，把这段字符串作为char的集合来看待，因此可以这样操作：

```rust
let str4 = "你好，世界！".to_string();
let first = str4.chars().nth(0); // 注意这种写法可能会取不到值，返回None
let second = str4.chars().nth(1);
if let (Some(ele1), Some(ele2)) = (first, second) {
    println!("str is {str4}, single is {ele1}, {ele2}");
}
for c in str4.chars() { // chars()方法返回一个迭代器，可以使用for in遍历
    println!("{c}");
}
```

注意char类型是基本类型，可以复制的，因此上述访问下标的方法实际上是在拿到字符串的单个char之后进行了复制。

字符串的`chars()`方法会返回一个char类型的迭代器（后面会提到），支持使用for in遍历，同理如果需要把字符串作为字节流进行处理，则也可以使用`bytes()`方法返回一个byte字节类型的迭代器。



##### set集（这块在lang book里面没有和hash map放在一起，很奇怪）

set类型在一般编程语言内都有，表示存储不重复的集合概念，RUST标准库中也有对应的实现，具体是HashSet和BTreeSet，前者是基于哈希算法实现的，后者是基于二叉树（Binary Tree）实现的。它们的写法如下：

```rust
use std::collections::{BTreeSet, HashSet};

let mut set1: HashSet<i32> = HashSet::new();
set1.insert(1);
set1.insert(2);
set1.insert(3);
if let Some(val) = set1.get(&2) {
    println!("{val}");
}
println!("{set1:?}"); // 结果是乱序的

let mut set2: BTreeSet<String> = BTreeSet::new();
set2.insert("a world".to_string());
set2.insert("without".to_string());
set2.insert("pain".to_string());
if let Some(val) = set2.get("pain") {
    println!("{val}"); // 这里所有权没有转移，val是&String类型
}
println!("{set2:?}"); // 会按照字母升序排列
```

HashSet和BTreeSet都用于维护不重复元素，但是它们有特性上的差异，总体上HashSet基于散列算法的性能会更好，在存储查询上都会更快，但是代价是散列算法不会保证元素的有序性，而BTreeSet性能虽然更差（参考二叉树的查询耗时），但会保证元素的有序性。



##### 哈希表

哈希表在各种语言中都有应用，特别是在算法领域，使用哈希算法可以大幅减少查询耗时，以做出高性能的算法。

和HashSet类似，RUST也提供了HashMap类，即也是散列算法存储key和value。注意和数组一样，HashMap自身的所有权和其存储元素（键值对）的所有权都是统一的，存储的时候会把键值的所有权转移到集合内，查询时key和value都需要使用引用类型，举例：

```rust
use std::collections::HashMap;

let mut accounts: HashMap<String, String> = HashMap::new();
let user1 = ("Arc".to_string(), "1234".to_string());
accounts.insert(user1.0, user1.1); // 这里所有权就转移了，user1后续不能再使用
let query_key = "Arc";
if let Some(val) = accounts.get(query_key) {
    println!("key is {query_key}, value is {val}");
}
println!("{accounts:?}");
```

哈希表也支持使用for in遍历，还是要注意for in会转移所有权的问题：

```rust
for (key, val) in &accounts {
    println!("key = {key}; value = {val}");
}
```

当然如果key和value都是基本类型，有copy特性，那么无论是存储还是查询，都不会有所有权的问题。

要更新某个key对应的value，只需要再次调用insert传入同等值的key即可，哈希表同一个key不会存2份value。

如果希望当某个key不存在的时候才存入，如果存在了则保持现有值，可以这样写：

```rust
accounts.entry(String::from("Yellow")).or_insert("yello pw");
```

注意`entry`方法，如果key存在时，不会执行or_insert，并返回对应的value的引用，这样我们就可以基于这个引用做进一步修改了，即实现更新某个key对应的value值，而且更新逻辑和旧value值有关联。

