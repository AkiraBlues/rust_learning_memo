## Arbitrum learning memo

专门介绍Arbitrum相关知识点。



#### 入门

Arbitrum是2021年开始的一项技术，是以太坊L2的一项解决方案，目标是实现快速高效且经济的交易。它没有构造侧链，而是通过部署一些去中心化的服务器，允许在链下高效完成交易，最后再批量提交到链上。

因为它大量的业务是在它自己的服务器上完成的，**相当于是对L1的业务进行代理**。

因为核心是业务代理，所以Arbitrum有几个特点：

- 基于L2思路，增加了拓展性
- 降低了GAS成本

- 安全性依赖于以太坊
- 可以像在以太坊转账那样在Arbitrum上转账或者开发部署智能合约

Arbitrum自身也提供去中心化网络的支持，比如它主要的Arbitrum One和Arbitrum Nova都是生产环境网络，当然也提供了测试环境网络，开发者也可以在本地搭建相关开发环境。



#### L2技术之Rollup链

由于Arbitrum就是L2的一种实现，因此它应用了其他的L2技术，其中最核心的就是，叫rollup，在区块链行业中一般也称为rollup链，它和L1链一样有区块，区块之间也和L1链一样通过parentHash指向上一个区块，它实际上就是去中心化的网络节点，也存储L2区块数据。

rollup技术在2019年由以太坊创始人提出概念，之后在2020年开始应用，目前有2套方案，Optimistic Rollups和ZK-Rollups。

Optimistic Rollup，即乐观Rollup，**它假设所有交易都是有效的，在被证明无效之前**。因为都是有效的，在链下完成交易后，会一视同仁地提交到以太坊L1链（也就是以太坊主链），之后给出一段挑战时间（一般是7天），在此期间任何人都可以提出证明，来否认交易的有效性，如果证明有效，则这批待确认的交易需要重新执行，负责提交的序列器（类似智能合约）会被检视和处罚，如果没有问题，则7天之后交易得到确认，**用户也只能在交易确认后提取加密货币**，即一切顺利的话链下交易后7天才能提现。

ZK-Rollup，即Zero Knowledge Rollup，零知识，**它假设所有交易都是有问题的，因此在提交到L1之前都需要被验证**，如果验证通过，提交到L1的数据除了交易本身，也包含了L2对交易有效性的背书（证明），之后这部分信息会转给L1的智能合约，如果合约验证了背书，则会把交易数据确认到L1链上。因为验证是在L2平台完成的，L1的智能合约只做审核，因此用户在交易确认后就可以立刻提现。但是显然，**这种背书会带来一定的中心化风险，特别是如果证明过程只有少数节点参与的话**。



#### AVM

Arbitrum的解决方案就是去中心化的服务器，而且它也参考了以太坊，设计了它自己的虚拟机，即AVM，在这些服务器上运行AVM，部署Arbitrum兼容的智能合约代码。Arbitrum Classic是它的早期网络，每个节点都运行了AVM，后续升级为Arbitrum Nitro，直接使用部署所在的OS能识别的机器码来执行，**因此抛弃了AVM**。

Arbitrum Nitro抛弃AVM是这样处理的（实际上是通过Stylus实现的，后续会提到），它通过一个编译器，来把正常的业务代码编译为当前OS的机器码，以执行正常的业务交易，当需要处理欺诈证明（后续会提到）时，又会把代码编译为WASM，以方便L1链的智能合约直接调用。因为正常的业务流程可以通过机器码完成，和L1链的交互可以通过WASM让L1链的VM去执行，因此Arbitrum Nitro自身可以抛弃AVM。



#### 相关网络

```
 - - - - - -             - - - - - - -             - - - - - - - 
|Arbitrum One|          |Arbitrum Nova|           |Arbitrum Orbit|
 - - - - - -             - - - - - - -             - - - - - - - 
      \                        |                         /
       \                       |                        /
        \                      |                       /
         \                     |                      /
          \                    |                     /
               ------------------------------------
              |Arbitrum Classic ===> Arbitrum Nitro|
               ------------------------------------
```

最初是Arbitrum Classic网络，之后升级为Aribitrum Nitro，然后基于这个网络构建了One，Nova和Orbit。后续开始先介绍Arbitrum One网络相关知识点，Nova在技术上和One是类似的，但是一些流程和协议和One不同。



#### Sequencer（序列器）

序列器是它的网络节点中的一类特殊节点，用于处理交易的时序问题，以及打包生成新的L2区块，从这个角度看序列器有点像L1的矿工，但是它们不依赖GAS，形成新的区块后也没有奖励，因为控制它们的是程序，所以**序列器就类似自动创建L2区块的智能合约**。Arbitrum的交易是按照时间顺序进行的（因为不需要依赖GAS费和矿工的个人偏好），也和以太坊一样会进入一个临时交易池，同样如果待太久也会被废弃。一般在整理好交易数据后，序列器会继续把这部分数据交给另一个程序，状态转换函数（State  Transition Function，STF）来进一步加工交易信息，加工完成后，序列器把结果提交到L1。

状态转换函数严格来说不是序列器内部的程序，但它一般会存在于序列器节点中，主要的任务就是进一步加工序列器提交的数据，具体有：

- 初步验证交易是否可执行，比如发起转账的人，它的余额是否足够
- 更新对应账户的状态

STF的工作过程可以完全预测的，也是可以本地运算的，因为只要已知所有的交易单，就可以计算出这一批交易执行后的当前区块的状态，**所以它更新区块或创建区块都不需要共识机制，因为结果就是纯数学运算的问题**。处理完成后，STF会直接更新当前L2区块的状态，甚至创建新的L2区块（有待确认），并把更新结果返还给序列器，最后序列器把结果提交到L1。

在提交到L1确认之前，交易属于软确认状态，提交到L1之后，就属于硬确认状态了。



#### Fraud Proof（欺诈证明）

Arbitrum的序列器和STF在处理完L2交易后，会批量提交给L1，此时就进入了欺诈证明环节，即在一个给定时间内，所有参与者需要给出这批交易内存在虚假的交易或者篡改的交易，并给出证明，**一旦某个参与者挑战并给出了证明，L1的智能合约会自动验证这个证明的有效性**，即参与者发起挑战后，后续的过程基本就是自动化的了，**如果一个批次内存在无效交易，则整个批次的交易都要被视为无效**，相关的L2数据也要回撤到提交这批交易之前的状态，有点类似于数据库的事务的设计了。

此外，L1智能合约实际上是通过Arbitrum Nitro的WASM代码来验证欺诈证明是否有效的，即Arbitrum提供了验证方法和验证程序，L1链的智能合约只负责调用这部分程序，程序是WASM格式。

此外，Arbitrum采用了改进的验证欺诈证明的流程，叫做交互式欺诈证明，以降低合约调用WASM代码验证欺诈证明的负担（传统的欺诈证明，完全依赖智能合约执行L2的WASM代码的效率）。在这个新流程中，质疑方和被质疑方（质疑方=挑战者，被质疑方=自证者）需要轮流提交一部分的证明，以解决质疑点，分歧点。比如挑战者先提交证明到L1智能合约，之后多轮流程开始，每轮都需要双方提供证明，当最后出现无法协调的分歧点时，才会触发智能合约的接入和验证，并最终判决。



#### Arbitrum Nova

这个Nova和One底层都是Nitro网络，但是上层有区别。简单来说Nova构建了一个小组，牺牲了部分去中心化，换来了效率。Nova内部有一个Data Availability Committees，DAC，数据可用性委员会，它是AnyTrust协议的产物。

AnyTrust更像是一个协议而非技术，它规定了一个DAC组织用于存储数据和提供数据，组织内有2票否决权，任何决策都需要N - 1个成员来配合，因此如果有2个成员是正直的，不配合错误的决策，则决策就无法执行。DAC管理和提供数据，因此数据不是去中心化的，这样可以降低成本。

DAC通过让N - 1个成员对数据进行签名，提供了DA Cert，数据可用性证书，来背书数据的正确完整性。所有证书都有对应的哈希值、过期时间和N - 1成员的签名证据。

AnyTrust协议不仅规定了DAC，还规定了委员会运行的软件，即DA Server，它一般提供2类API，针对序列器的API和REST API，前者智能由序列器访问，后者是全球开放的，可以通过哈希值查询出对应的数据块。序列器API有写入修改权限，即序列器通过向此API提交L2交易数据，以形成新的L2区块，REST API则只有查询权限。

注意，**不像Arbitrum One那样，序列器搜集的交易都会发布到L1链，在Nova网络下，L2数据由DAC管理，存储于DA Server内，DAC一般只把对应的DA Cert而非完整数据发布到L1链，只有在必要时（签名失败时）会把完整数据发布到L1链**。这个设计本身就是带有中心化风险的，所以通过N-1签名机制，让DAC主要成员为这些数据背书。当序列器搜集到足够的数据，准备写入DA服务器时，会需要N - 1签名，如果签名成功，则签名后的证书发布到L1链，如果签名失败（比如成员时间不够或者参与人数不够），则表示AnyTrust协议不成立，此时则回退到One的模式，即完整数据会被提交到L1链，然后进入欺诈证明环节，后续处理流程和One网络是一样的。

所以，Nova场景下，一般数据都是存储于DA服务器，而One场景下都是存于L1链上，数据可用性是两个网络的最大差异。Nova通过牺牲部分去中心化换来了效率，适用于对延时很敏感的场景，比如游戏，社交媒体等。



#### Arbitrum Orbit

Orbit是一个支持用户自定义的网络，2023年推出，它是L2和L3兼容的，如果选择了L3方案则可以和L2交互，如果选择了L2方案则需要自己去和L1交互。这种更适合企业级平台。它的特点有：

- 带宽是专用的，因为是L3网络，不需要受到L1的限制
- 支持EVM+，因此可以使用多种语言来开发智能合约
- 支持后续独立于以太坊的产品演化路线，因为它本质也是off-chain
- GAS价格更独立稳定，目前L1的GAS价格是受制于整个链的繁忙程度控制的，即使自身业务很清闲但如果整体很繁忙，GAS费用也会很高，使用Orbit可以让GAS价格更独立稳定，因为带宽和计算资源都是专用的，所以其他业务的繁忙程度不会影响到自身的GAS价格
- GAS代币可自定义，只要是符合ERC-20标准的就可以

备注一下，ERC是以太坊社区进行制定和维护的一系列标准，相当于以太坊社区的一套共识，其中ERC-20定义了什么是代币，和代币的一些必备能力，比如总供应量，转账，查询余额等等



#### Arbitrum Stylus

arbitrum stylus本身不是一个独立的分布式网络，类似one或者nova，而是在nitro技术上进一步升级，核心是恢复了nitro节点的虚拟机配置，但是把AVM改为了支持WASM的虚拟机，因此使得任何nitro节点既可以直接执行编译为机器码的智能合约，又可以执行编译为WASM的智能合约，前者给L2网络提供直接支持，后者用于跟L1链交互。

也可以理解为，**L1链通过EVM执行智能合约，arbitrum stylus则在L2链上增加了支持WASM的虚拟机，使得L1链也可以通过调用L2链节点来执行WASM，因此L1链节点也间接具有了执行WASM的能力，因此从外部看是对EVM的增强，即EVM+**。

同时由于这个增强，任何可以编译为WASM的语言都可以用于编写arbitrum的智能合约，这就是arbitrum虽然是EVM生态但是可以支持RUST的原因。此外stylus对RUST的支持会更优先于其他语言，因为它性能更好，更小的算力开销就可以完成任务，因此应用于链上可以降低GAS费用。



#### 以太坊智能合约介绍

这段主要参考以太坊的教程。

智能合约部署在区块链上的自动执行的程序，且一旦知道了输入参数，结果可以预测，因而执行过程不存在随机性。它在进行判断时，遵循的逻辑是预先写好的，因此不需要人来参与决策。

智能合约可以操作代币，即它可以接收代币，存储代币，发放代币，也可以调用其他智能合约。

一般会用自动售货机来表示智能合约，即它的商品是确定的，人可以发起购买流程，选择了商品后，售货机会接收金钱（代币），把人选择的商品从货架上推出，商品掉落到底部取货口，最后人取走商品，整个过程都是可以预测的，其他的异常场景也是可以预测的。

**智能合约是部署在区块链的世界状态树内，单独的区块只在区块头记录它作为最新区块时的世界状态树的状态根的哈希值，因此不包含智能合约代码**，而由于每个完整节点都保存了一份最新的世界状态树，因此每个完整节点也保存了所有部署的智能合约，而且它一旦部署就不能修改，因此每个完整节点运行的这份智能合约，代码都是一样的。

智能合约主要是用来处理区块链上的用户间的不信任问题，现实世界，不信任的双方进行货物交换，一般都要借助中立的三方平台，比如参考淘宝闲鱼，买家钱都是先打款到平台上，确认收货后平台才会把钱转给卖家。当然三方平台是否足够中立也是问题，比如P2P暴雷这种事情也是发生过的，平台也有可能跑路。

而在去中心化平台上，没有所谓的中立三方平台，因此交易双方就借助智能合约来完成交易，而因**为智能合约的所有行为是可以预测的，无法修改也无法销毁，生命周期和区块链保持同步，而且所有判断过程都是可预测的，判断过程没有真人参与，因此实际上会比三方平台更加中立也更加可靠**。

当然这样吹智能合约也不对，它也是有缺陷的，**因为智能合约可以保存代币，而且代码透明，因此理论上黑客可以通过研究智能合约的代码来制定攻击策略，从而盗取代币**，这种事情实际上发生过，以太坊历史上最严重的一次黑客攻击发生在2016年，黑客通过上述步骤攻击了一个众筹项目，导致了大量资金损失并最终迫使以太坊区块链发生分叉，成为了ETH（以太坊）和ETC（以太坊经典），之后以太坊社区就更加重视智能合约的安全性和代码审查，比如给开发者提供更加安全的开发SDK，或者安全编程范式，或者部署前的代码审计服务等等。

以太坊把智能合约视为世界状态树上的节点，每个智能合约都有2类存储数据的空间，Storage和Memory。

Storage是会存储在状态世界树内的，因此对它的修改会导致广播事件，从而触发所有完整节点去更新对应的世界状态树，所以修改Storage会导致极大的开销。此外，虽然以太坊对智能合约可以使用的Storage没有明确限制，但是它会影响GAS费用，即**如果一个智能合约在Storage内存储了大量数据，那么每次调用此智能合约的GAS费就会更高**，从而使得此智能合约在商业上更不受欢迎。

Memory是执行代码中的临时数据，只在每次执行合约代码时创建，执行结束后就会销毁，不会存储在世界状态树内，因此可以支持频繁地修改。



#### 用Stylus Rust SDK写智能合约

Arbitrum推出Stylus主要目的就是实现用高效的RUST语言可以写以太坊合约。在Stylus之前，以太坊生态和Solidity语言是高度绑定的，就像KOTLIN和安卓那样，javascript和前端开发那样。但是在Stylus推出之后RUST也可以用于以太坊智能合约的开发，扩宽了以太坊生态的面向开发人群，还有其他的增强。









