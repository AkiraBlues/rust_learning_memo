## Arbitrum learning memo

专门介绍Arbitrum相关知识点。



#### 入门

Arbitrum是2021年开始的一项技术，是以太坊L2的一项解决方案，目标是实现快速高效且经济的交易。它没有构造侧链，而是通过部署一些去中心化的服务器，允许在链下高效完成交易，最后再批量提交到链上。

因为它大量的业务是在它自己的服务器上完成的，**相当于是对L1的业务进行代理**。

因为核心是业务代理，所以Arbitrum有几个特点：

- 基于L2思路，增加了拓展性
- 降低了GAS成本

- 安全性依赖于以太坊
- 可以像在以太坊转账那样在Arbitrum上转账或者开发部署智能合约

Arbitrum自身也提供去中心化网络的支持，比如它主要的Arbitrum One和Arbitrum Nova都是生产环境网络，当然也提供了测试环境网络，开发者也可以在本地搭建相关开发环境。



#### L2技术之Rollup链

由于Arbitrum就是L2的一种实现，因此它应用了其他的L2技术，其中最核心的就是，叫rollup，在区块链行业中一般也称为rollup链，它和L1链一样有区块，区块之间也和L1链一样通过parentHash指向上一个区块，它实际上就是去中心化的网络节点，也存储L2区块数据。

rollup技术在2019年由以太坊创始人提出概念，之后在2020年开始应用，目前有2套方案，Optimistic Rollups和ZK-Rollups。

Optimistic Rollup，即乐观Rollup，**它假设所有交易都是有效的，在被证明无效之前**。因为都是有效的，在链下完成交易后，会一视同仁地提交到以太坊L1链（也就是以太坊主链），之后给出一段挑战时间（一般是7天），在此期间任何人都可以提出证明，来否认交易的有效性，如果证明有效，则这批待确认的交易需要重新执行，负责提交的序列器（类似智能合约）会被检视和处罚，如果没有问题，则7天之后交易得到确认，**用户也只能在交易确认后提取加密货币**，即一切顺利的话链下交易后7天才能提现。

ZK-Rollup，即Zero Knowledge Rollup，零知识，**它假设所有交易都是有问题的，因此在提交到L1之前都需要被验证**，如果验证通过，提交到L1的数据除了交易本身，也包含了L2对交易有效性的背书（证明），之后这部分信息会转给L1的智能合约，如果合约验证了背书，则会把交易数据确认到L1链上。因为验证是在L2平台完成的，L1的智能合约只做审核，因此用户在交易确认后就可以立刻提现。但是显然，**这种背书会带来一定的中心化风险，特别是如果证明过程只有少数节点参与的话**。



#### AVM

Arbitrum的解决方案就是去中心化的服务器，而且它也参考了以太坊，设计了它自己的虚拟机，即AVM，在这些服务器上运行AVM，部署Arbitrum兼容的智能合约代码。Arbitrum Classic是它的早期网络，每个节点都运行了AVM，后续升级为Arbitrum Nitro，直接使用部署所在的OS能识别的机器码来执行，**因此抛弃了AVM**。

Arbitrum Nitro抛弃AVM是这样处理的，它通过一个编译器，来把正常的业务代码编译为当前OS的机器码，以执行正常的业务交易，当需要处理欺诈证明（后续会提到）时，又会把代码编译为WASM，以方便L1链的智能合约直接调用。因为正常的业务流程可以通过机器码完成，和L1链的交互可以通过WASM让L1链的VM去执行，因此Arbitrum Nitro自身可以抛弃AVM。



#### 相关网络

```
 - - - - - -             - - - - - - -             - - - - - - - 
|Arbitrum One|          |Arbitrum Nova|           |Arbitrum Orbit|
 - - - - - -             - - - - - - -             - - - - - - - 
      \                        |                         /
       \                       |                        /
        \                      |                       /
         \                     |                      /
          \                    |                     /
               ------------------------------------
              |Arbitrum Classic ===> Arbitrum Nitro|
               ------------------------------------
```

最初是Arbitrum Classic网络，之后升级为Aribitrum Nitro，然后基于这个网络构建了One，Nova和Orbit。



#### Sequencer（序列器）

序列器是它的网络节点中的一类特殊节点，用于处理交易的时序问题，以及打包生成新的L2区块，从这个角度看序列器有点像L1的矿工，但是它们不依赖GAS，形成新的区块后也没有奖励，因为控制它们的是程序，所以**序列器就类似自动创建L2区块的智能合约**。Arbitrum的交易是按照时间顺序进行的（因为不需要依赖GAS费和矿工的个人偏好），也和以太坊一样会进入一个临时交易池，同样如果待太久也会被废弃。一般在整理好交易数据后，序列器会继续把这部分数据交给另一个程序，状态转换函数（State  Transition Function，STF）来进一步加工交易信息，加工完成后，序列器把结果提交到L1。

状态转换函数严格来说不是序列器内部的程序，但它一般会存在于序列器节点中，主要的任务就是进一步加工序列器提交的数据，具体有：

- 初步验证交易是否可执行，比如发起转账的人，它的余额是否足够
- 更新对应账户的状态

STF的工作过程可以完全预测的，也是可以本地运算的，因为只要已知所有的交易单，就可以计算出这一批交易执行后的当前区块的状态，**所以它更新区块或创建区块都不需要共识机制，因为结果就是纯数学运算的问题**。处理完成后，STF会直接更新当前L2区块的状态，甚至创建新的L2区块（有待确认），并把更新结果返还给序列器，最后序列器把结果提交到L1。

在提交到L1确认之前，交易属于软确认状态，提交到L1之后，就属于硬确认状态了。



#### Fraud Proof（欺诈证明）

Arbitrum的序列器和STF在处理完L2交易后，会批量提交给L1，此时就进入了欺诈证明环节，即在一个给定时间内，所有参与者需要给出这批交易内存在虚假的交易或者篡改的交易，并给出证明，**一旦某个参与者挑战并给出了证明，L1的智能合约会自动验证这个证明的有效性**，即参与者发起挑战后，后续的过程基本就是自动化的了，**如果一个批次内存在无效交易，则整个批次的交易都要被视为无效**，相关的L2数据也要回撤到提交这批交易之前的状态，有点类似于数据库的事务的设计了。

此外，L1智能合约实际上是通过Arbitrum Nitro的WASM代码来验证欺诈证明是否有效的，即Arbitrum提供了验证方法和验证程序，L1链的智能合约只负责调用这部分程序，程序是WASM格式。

此外，Arbitrum采用了改进的验证欺诈证明的流程，叫做交互式欺诈证明，以降低合约调用WASM代码验证欺诈证明的负担（传统的欺诈证明，完全依赖智能合约执行L2的WASM代码的效率）。在这个新流程中，质疑方和被质疑方（质疑方=挑战者，被质疑方=自证者）需要轮流提交一部分的证明，以解决质疑点，分歧点。比如挑战者先提交证明到L1智能合约，之后多轮流程开始，每轮都需要双方提供证明，当最后出现无法协调的分歧点时，才会触发智能合约的接入和验证，并最终判决。

