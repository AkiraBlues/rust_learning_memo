## Ethereum & Solidity learning memo

专门介绍以太坊 / Solidity相关知识点。



#### 入门

以太坊（官网点[这里](https://ethereum.org/en/)），是一个分布式虚拟机网络，开发者可以在上面部署DApps。2015年以太坊正式启动。

以太坊和比特币最大的区别是，比特币是去中心化数据库，而以太坊是去中心化虚拟机，因此它支持跑DApps以拓展更多能力，DApps的本质就是智能合约，即一段预先设定好规则的程序，触发条件后会自动执行，且程序本身必须完全开源，以方便所有人审查是否有黑箱操作。另外以太坊通过POS而非POW的共识机制来创建区块，使得交易可以更快得到确认，因此效率比比特币更高一些。

实际上以太坊在2015年初期创建时还是基于POW机制的，改为POS要到**2022年，进入以太坊2.0时代**。

开发者或用户接入以太坊，都需要创建账户，这里有2种类型：

- EOA，Externally Owned Accounts，外部账户，即一般的私人账户，由真实的人类进行控制，只能进行转账
- CA，Contract Accounts，合约账户，通过智能合约创建的账户，由智能合约进行控制，由于智能合约的程序逻辑是写死的，因此不能基于人的行为来干涉，但是**它也不具备自启动特性，需要由外部账户来手动启动**

以太坊账户包含以下字段：

- nonce，如果是外部账户，它表示交易次数，新账户默认是0，如果是合约账户，它表示执行合约操作的次数，默认是1，表示合约账户被创建了
- balance， 余额，合约账户也可以有余额，比如如果需要空投，那么这个过程可以是，创建一个合约账户，给它设定好空投规则，并充值，此时合约账户也有余额
- codeHash，只针对合约账户存在，即它包含的以太坊虚拟机（EVM）的代码的哈希值，对于外部账户，此字段是空字串，哈希这个工具是防止合约账户的代码被篡改，一般来说合约账户一旦部署，其代码原则上不能更改，但是以太坊也允许在特定条件下修改代码
- storageRoot，以太坊也用到了Merkle Patricia Tree结构来存储数据，因此每个账户的数据都会对应一个这个树结构，这个字段用于记录树的根节点的256位哈希值，这样基于哈希来找到存储根节点，从而查询账户数据，就会比较快

此外，外部账户还拥有私钥和公钥，用于确认这个账户是由一个真实的人类来控制的，而合约账户没有私钥和公钥，因此它的地址也不能基于公钥来运算，而是基于部署它所对应的智能合约的负责人的钱包地址和一个nounce值来确定的。



#### 共识机制

这个还是在bootcamp的课程里面看到的比较好的说明。

在一个去中心化的网络中，各个节点之间的协作是一个痛点，比如怎样确保各个节点和全局状态保持一致（比如某个交易导致了总供应量的变化，各个节点如何接收到这个信息），如何新增区块，如何确保交易不是伪造的，这些都需要共识机制的参与。

共识机制是一组原则，最核心的原则是：

- 一个代币不能用于支付2笔交易，即消费2次
- 最长链原则，即如果出现分叉了（通常是由于POW的矿工竞争机制导致同时创建了2个区块），**区块链会暂时进入分叉状态，由后续区块来选择哪个分支更长**，因为还是分布式网络，部分节点会选择分叉A（因为它先收到了分叉A的广播），部分节点会选择分叉B（同理，它先收到分叉B的广播），但如果后续又有新的区块出现了，它如果加入到分叉A，那么意味着分叉B是更短的链，分叉A是更长的链，此时分叉B的所有交易会被视为无效，而回滚，分叉A会被视为主链

- 单独验证，即如果全局状态产生了变化，通常是因为有了交易，可以基于同一套验证方式，让各个节点单独验证这些交易是否有效（有点类似科学发现，A小组发表了试验过程和结果，其他小组按照A小组的步骤去验证，只不过这里的步骤是先于区块链成立的，所有节点都要遵守）

- 51%认同，即随着网络传播，这个状态变化被一个个的节点进行验证，当总体验证数量达到了51%，那么这个变化就是全局认可的，当然未确认的节点也是需要继续做确认的，一般来说不会有问题，如果出现冲突，就需要基于最长链原则来解决，这个也是共识机制的一部分

POW也是一种共识机制，但它不是最核心的，因为还有POS，POH等等。这些共识机制是用于决定如何创建新区块的，比如POW就是纯粹的矿工竞争，谁运气好算力高，谁就能解开数学题从而确认交易，形成新区块，POS则是看谁有门票，谁运气好，POH则是在过程中加入了时间戳，以标记交易的先后顺序。

另外POW中挖矿难度也是基于自动化算法控制的，即根据过去一段时间的新区块产生速度，来调整当前的难度，简单来说如果挖矿的人少，难度就会下降，如果人多，难度就会上升，这一切都是通过一个算法自动控制的，这个算法也是比特币创建者中本聪在一开始的白皮书里面提到的，后面他也给出了算法细节。





#### 数据存储

以太坊的数据存储结构采用三棵树来完成。因为它也是区块链结构，因此数据自然会存于区块内，而每个区块记录它上一个区块的哈希值，即parentHash来确保整个区块的完整性。但是这里有一个问题，是否每个区块都要完整的记录整个区块链的状态呢？理论上如果每个区块不记录，而是只记录自身的结构，那么整个区块链会面临篡改风险，所以需要让每一个水滴都可以是一片大海，但是实际上如果真这样存储那么所需的空间是指数级增长的，所以以太坊采用了一个简化的策略，即**区块头只包含某类数据的根节点的完整性信息，而具体的数据还是存在于各个区块内**，这样设计的好处是每个区块头都能提现整个区块链的状态，因此可以防止篡改，另外每个区块只存储完整性校验的信息，不存储实际的数据，因此所需的空间是固定的。

具体来说，以太坊设计了3棵树，**记住，这些树是分布式地保存在所有区块链的完整节点上的，且同时每个区块都要在区块头记录它作为最新区块时的这3棵树的根节点状态（不是数据，而是状态）**：

- 世界状态树，用于全面地记录所有的状态
- 交易树，保存所有的交易记录
- 回执树，可以视为交易的日志树，即除了交易信息之外还记录了执行结果，消耗的GAS，其他日志等等

上述三棵树都是Merkle Patricia Tree，因此它们的根节点的哈希值就是整个树的哈希值，每个区块头记录这些哈希值，就等同于**每个区块都会提现当它是最新创建的区块时，当时的区块链整体的状态**。当有交易存储到最新区块时，区块头的信息会被改写，但一旦新区块创建，上一个区块的信息就固定了，类似某种时间胶囊，或者日志，可以让所有人知道当前的区块链状态，**最新的状态变动只会发生在最新的区块内，之前的区块头不再提现最新的状态信息**。

这种设计思路和前端的REACT框架很像，即通过连续地记录状态，或者状态的变化，来允许开发者和用户执行某种程度的”时间回溯“，以把系统切回到之前某个时间点（最简单的比如填写的表单，可以通过撤回键回到上一个填写提交的版本）。对于区块链来说，每个区块都是记录一段时间的整体状态，之后新区块被创建，它成为了不可篡改的历史。



#### 不对称加密补充

传统加密通信都是对称的，也就是说**A和B进行通信之前，A必须要通过其他渠道告知B，A使用的密钥**。这里存在信任问题，因为A和B共享一套密钥，**如果A不相信B，是不可能把密钥共享给B的**，所以A要和B建立信任关系。

不对称加密就是用来解决这个问题的，它本质上解决了互信问题，A和B通信之前，A可以不需要通过其他渠道和B接触，A不需要信任B，**A只需要假设B持有B的私钥即可**，因为不对称加密有2种场景：

- 在通信场景下，A用B的公钥加密消息，B收到消息后用B的私钥解密，假设A的消息是广播出去的，那么也只有B可以解密，因为只有B有B的私钥
- 在证明场景下，A用自己的私钥加密，然后广播出去，所有人都可以用A的公钥来解密，从而证明这个信息是A创作的

主流的不对称加密方式是RSA和ECDSA（椭圆曲线），目前ECDSA更主流因为使用开销更小。



#### 交易

**交易是必须由外部账户发起和私钥签名的行为**，它包含几个要素：

- from，发起者的钱包地址，**合约账户无法自行发起交易，必须是外部账户才可以**
- recipient，接收方，可以是外部账户或者合约账户，如果是合约账户，还要执行合约代码
- signature，发起者的私钥参与的签名
- nonce，发起者的账户交易次数，每交易一次都会使得其+1
- value，发起者转移的以太币数量，货币单位是WEI，$1 ETHER = 10^{18} WEI$，即1个以太币等于10的18次方的WEI，给以太币定这么大的价值，或者给WEI定这么小的价值，都是为了支持高精度的交易金额计算 
- input data，可支持发起方输入任意信息，一般在处理合约时这部分要填写合约代码
- gasLimit，交易所需的GAS最大值，如果矿工需要比它更大的GAS才能确认交易，则交易不会被确认
- maxPriorityFeePerGas，给矿工的每GAS对应的小费，类似打车软件的加价调度，所以如果这块给得多，可以增加交易被确认的速度
- maxFeePerGas，愿意支付的对应每GAS的最大费用，包括每GAS基础费用baseFeePerGas（由行情和网络繁忙程度确定）和maxPriorityFeePerGas，即每GAS给矿工的加价

交易类型有以下几种：

- 一般交易，即P2P的外部账户间的交易
- 合约部署交易，没有接收方地址（也可以理解为接收方就是整个区块链），此时需要在input data内提交合约代码
- 执行合约交易，即由外部账户发起的执行合约的行为，此时接收方是合约账户

交易的具体步骤：

1. 只有外部账户可以发起交易，因此先由外部账户发起并私钥签名
2. 广播，即交易最终会被广播到全区块链，从用户所在的节点开始，逐步扩散到其他节点，当然也会到达矿工节点，进入这些矿工所收集的待处理交易池（不同矿工看到的待处理交易池可以不同，这个要看矿工自己的配置，以及它更新的频率）
3. 进入池子之后，矿工会从池子中选择它觉得比较靠谱的交易，用来存入到下一个区块内，一般矿工会选择小费较高的交易，矿工验证交易有效（就是比对交易数据的哈希值和发起方的公钥解密的签名是否一致）后，就会纳入到下一个区块内
4. 交易被矿工挑出后，打包到了一个新的区块，新的区块形成，交易也被确认，如果后续不断地交易确认，产生新的区块，则之前的交易就不会被逆转，最终成为区块链不可篡改的一部分

GAS和WEI不同，它没有一个和以太币固定的兑换比例，可以理解为**GAS有一个市场波动价格，随着网络繁忙程度而变化**。到2025年初，1以太币约等于693GAS。

另外以太坊以安全和严格著称，因此虽然支持很多用户在任何时间点发起交易，但对矿工来说，**确认交易，存入区块的过程，永远都是单线程的**，而**以太坊也只允许单线程地创造新的区块**，所以本质上，**在任何时刻，全区块链上只允许执行最多一个交易**，以确保当知道了待执行的交易序列后，所有人都可以预测到这一系列交易的最后结果，因为它是线性执行的。



#### 以太币

以太币，也叫ETH，是以太坊生态内的货币，1ETH等于10的18次方的WEI。

最初的以太币是在2014年通过众筹的方式，参与者通过比特币进行交换的，即它最初的价值是比特币背书。

之后以太坊参考比特币的POW机制，每创造一个新的区块，都会发行新的以太币以便给矿工提供奖励。

2022年升级到POS之后，同样还是每创建一个新的区块，创建者会获得新发行的ETH作为奖励。

由于交易需要GAS，而每次交易都会有基础GAS，而**这部分在交易完成后，不会作为任何人的奖励，而是会被销毁，即交易发起者，每次交易都会因为基础GAS导致轻微的资产损失，因此GAS的设计会轻微降低ETH的流通量**。用于控制以太坊生态的通货膨胀。



#### 智能合约和EVM

智能合约就是运行在以太坊链上的程序。

合约账户用于创建和管理智能合约。每个合约账户可以创建多个智能合约，它自身的nounce值会随着合约操作而不断增加，但是只能部署一个智能合约，因此**每个新创建的智能合约，如果需要部署，则必须部署到新的合约账户上**。

所以合约账户和部署的智能合约是一对一的关系，即**每个合约账户只能部署一个智能合约，因为它内部只能存储一份合约代码**。

合约账户虽然没有公钥，地址由部署智能合约的人和nounce值确定，但**它和外部账户一样，一旦创建，地址就不可变了**，部署的智能合约也就和这个地址绑定了，如果其他人要使用它发起操作，则所有人也都必须把消息发送到它部署在的这个合约账户的地址。

常见的智能合约，一般会有代币发行和管理的能力，其他的合约甚至还可以实现P2P借贷，或者支持多方签名。在去中心化组织内，通过智能合约还可以发起投票，比如发起者通过智能合约发起投票议题和投票选项，其他参与者进行投票和确认，最后智能合约给出投票结果等等。

智能合约本质上就是部署在EVM上的开源代码，任何人都可以监视它的客观公正性，以及查看它所支持的能力。它就像一个API接口，用户发起使用请求，它就会按照这些编写好的程序给出响应。开发智能合约可以用多种语言，经过编译之后成为字节码，最后部署到EVM。

EVM就是以太坊虚拟机，正常小白用户使用以太坊是不需要涉及的，因为直接用DApps就可以，而如果需要开发智能合约，则需要本地部署EVM，以降低开发成本，提高开发效率，相当于本地搭建开发和测试环境。

另外除了交易会需要GAS外，**执行智能合约也需要支付GAS**，因为它本质上也是运行在各个去中心化节点上，也需要消耗算力和电力。



#### L1和L2

这部分是网上查资料看到的。

有一个理论，叫区块链不可能三角，即一个区块链不可能同时满足安全，去中心化，和拓展性，以太坊专注于安全和去中心化，因此它失去了拓展性，为此有很多人在研究怎么解决这个问题。

所谓拓展性就是保持现有能力和效率的前提下，扩大参与者数量和使用量。对区块链来说，拓展性就是增加交易频次，但不会导致功能缺失或者降级。

主流意见就是on-chain和off-chain，即链上（L1）和链下（L2），简单来说L1侧重于优化现有的链条，而**L2则侧重于绕开现有链条的限制去解决问题，然后再解决怎么把解决方案和主链交互的问题**。

基本上从2018年开始以太坊的拓展性问题得到了重视，之后各种技术和生态出现，主流的思路在向L2看齐，不少新的生态也是基于某个基础加密货币的L2来开发的，比如后面要学习的Arbitrum就是基于以太坊的L2解决方案，它本质是一个运行于L1之外的去中心化程序，因为部署和开发都不直接依赖L1，因此可以绕开L1的各种限制，进行更高效的操作，当然操作完成后还是要和L1进行交互以确认交易结果。





### Solidity智能合约语言学习

SOLIDITY语言用于编写以太坊的智能合约，它也需要编译，之后会转为字节码，然后通过发起交易的方式部署到以太坊虚拟机EVM上，最后EVM会给它分配一个地址，这样一个智能合约就部署完成了。

以太坊的GAS计算分为基础部分和行情部分，一个简单的数值相加操作，乘法等运算，会消耗固定的GAS费用，存储的部分会按照行情计算。



#### 环境搭建

操作系统是LINUX。

先安装NODEJS和NPM，在UBUNTU下官方建议是先安装NVM，而NVM需要通过CURL命令去下载一个脚本并执行脚本安装。

安装完成NVM后可以通过`nvm -v`测试一下。

然后通过NVM命令安装NODEJS，这个参考官方网站就可以了，确保NODEJS和NPM都可以通过命令访问到。

然后安装HARDHAT，它是开发兼容EVM虚拟机程序的开发环境，简单来说就是类似JRE的东西，包含了编译器和运行环境EVM，具体这样操作：

- VS CODE IDE先安装solidity拓展插件
- 创建一个空文件夹，然后执行npm init初始化
- 在这个项目内安装HARDHAT，执行`npm install -D hardhat`，之所以放在项目内去安装是为了确保其他项目可以安装不同版本的HARDHAT，这样如果出现问题，本地更好基于对应版本去复现，这里安装了2.22.19版本
- 然后执行`npx hardhat init`，注意到它提供了JS，TS等选择，这里的意思是**智能合约的部分还是用solidity语言去写，但是部署，编译，测试等等环节还是依赖JS代码**，所以一个完整的solidity项目里面也会有JS / TS代码的。选项里面有一个是否安装hardhat-toolbox，它是一个开发套件，就是集成了编译，测试，部署等功能，这里还是建议安装，少走一点弯路
- 初始化后可以看到有JS代码，也有SOL文件，里面写的就是SOLIDITY代码，定义智能合约，执行`npx hardhat compile`可以发现多出了一个文件夹`artifacts`，里面就是编译后的字节码，可以用于部署智能合约
- 后续，测试，部署，暂时省略……





#### HARDHAT CLI常用命令

因为HARDHAT是安装在项目中的，所以使用`npx hardhat`作为前缀，下面不再提及。

- --help，帮助
- init，初始化项目
- clean，清空缓存和构建结果

后面慢慢补充……



